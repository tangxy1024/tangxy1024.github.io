<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面经总结 | 有啥好卷的</title><meta name="author" content="从来不卷"><meta name="copyright" content="从来不卷"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="知识准备：springboot中偏底层的东西可以先学习SpringMVC.八股文记忆推荐：https:&#x2F;&#x2F;javaguide.cn&#x2F; 自我介绍 用简洁的话说清楚自己主要的技术栈于擅长的领域； 把重点放在自己在行的地方以及自己的优势之处； 重点突出自己的能力比如自己的定位的 bug 的能力特别厉害；  网上一般建议的是准备好两份自我介绍：一份对 hr 说的，主要讲能突出自己的经历，会的编程技术一语带">
<meta property="og:type" content="article">
<meta property="og:title" content="面经总结">
<meta property="og:url" content="http://tangxy1024.github.io/2023/06/17/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="有啥好卷的">
<meta property="og:description" content="知识准备：springboot中偏底层的东西可以先学习SpringMVC.八股文记忆推荐：https:&#x2F;&#x2F;javaguide.cn&#x2F; 自我介绍 用简洁的话说清楚自己主要的技术栈于擅长的领域； 把重点放在自己在行的地方以及自己的优势之处； 重点突出自己的能力比如自己的定位的 bug 的能力特别厉害；  网上一般建议的是准备好两份自我介绍：一份对 hr 说的，主要讲能突出自己的经历，会的编程技术一语带">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201301.jpg">
<meta property="article:published_time" content="2023-06-17T11:57:12.000Z">
<meta property="article:modified_time" content="2023-06-17T13:11:27.084Z">
<meta property="article:author" content="从来不卷">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201301.jpg"><link rel="shortcut icon" href="https://txy-typora.oss-cn-nanjing.aliyuncs.com/logo.jpg"><link rel="canonical" href="http://tangxy1024.github.io/2023/06/17/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":false,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面经总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-17 21:11:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/logo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201301.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="有啥好卷的"><img class="site-icon" src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/logo.jpg"/><span class="site-name">有啥好卷的</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面经总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-17T11:57:12.000Z" title="发表于 2023-06-17 19:57:12">2023-06-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-17T13:11:27.084Z" title="更新于 2023-06-17 21:11:27">2023-06-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">47.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>157分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面经总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>知识准备：springboot中偏底层的东西可以先学习SpringMVC.<br>八股文记忆推荐：<a target="_blank" rel="noopener" href="https://javaguide.cn/">https://javaguide.cn/</a></p>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><ul>
<li>用简洁的话说清楚自己主要的技术栈于擅长的领域；</li>
<li>把重点放在自己在行的地方以及自己的优势之处；</li>
<li>重点突出自己的能力比如自己的定位的 bug 的能力特别厉害；</li>
</ul>
<p>网上一般建议的是准备好两份自我介绍：一份对 hr 说的，主要讲能突出自己的经历，会的编程技术一语带过；另一份对技术面试官说的，主要讲自己会的技术细节和项目经验。<br>案例：<br><strong>校招：</strong><br>面试官，您好！我叫秀儿。大学时间我主要利用课外时间学习了 Java 以及 Spring、MyBatis 等框架 。在校期间参与过一个考试系统的开发，这个系统的主要用了 Spring、MyBatis 和 shiro 这三种框架。我在其中主要担任后端开发，主要负责了权限管理功能模块的搭建。另外，我在大学的时候参加过一次软件编程大赛，我和我的团队做的在线订餐系统成功获得了第二名的成绩。我还利用自己的业余时间写了一个简单的 RPC 框架，这个框架用到了 Netty 进行网络通信， 目前我已经将这个项目开源，在 GitHub 上收获了 2k 的 Star! 说到业余爱好的话，我比较喜欢通过博客整理分享自己所学知识，现在已经是多个博客平台的认证作者。 生活中我是一个比较积极乐观的人，一般会通过运动打球的方式来放松。我一直都非常想加入贵公司，我觉得贵公司的文化和技术氛围我都非常喜欢，期待能与你共事！</p>
<p>您好！我是XXX，来自XXX大三在读生一枚，所学专业为计算机科学与技术，我今天是来面试Java开发实习生这个职位的。<br>从大一开始我就跟着自己的导师开始研究JavaWeb方向，通过自身的学习我自学过Springboot等框架，同时也参加过大大小小的编程类竞赛获得了一些奖项。并由于对周围的环境的研究，我制作了几个平台可以为同学提供方便。<br>第一个项目，PLUS训练营，为计算机专业的同学提供了一个平台去寻找适合自己的练习项目从而提高自身的编程能力。第二个项目，失物招领网，为解决校内失物招领的问题，因此我设计了一个系统去专业化的管理这些信息。<br>在技术方面我认为这个实习岗位需要具备比较系统的基础java知识，数据库知识，并了解现流行的Springboot框架，而我基本都已经了解并运用。<br>在性格方面我有足够的耐心去做一件事，并且我喜欢这个工作，所以我觉得我可以较好的符合这个岗位。</p>
<h2 id="Java后端知识点"><a href="#Java后端知识点" class="headerlink" title="Java后端知识点"></a>Java后端知识点</h2><ul>
<li>Java 基础、集合、并发、MySQL、Redis、Spring、Spring Boot 这些 Java 后端开发必备的知识点。</li>
</ul>
<h2 id="面试经验"><a href="#面试经验" class="headerlink" title="面试经验"></a>面试经验</h2><h3 id="杭州天谷信息科技有限公司"><a href="#杭州天谷信息科技有限公司" class="headerlink" title="杭州天谷信息科技有限公司"></a>杭州天谷信息科技有限公司</h3><h4 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h4><ol>
<li>触发full gc的条件有哪些<ul>
<li>调用System.gc()</li>
<li>老年代空间不足</li>
<li>在执行CMS GC的过程中，如果此时有线程将对象放入老年代，并且老年代空间不足，或者在做Minor GC的时候，新生代Survivor空间不足，需要放入老年代，而老年代空间也不足，则触发Full GC。</li>
</ul>
</li>
<li>实现Java单例的方式<ol>
<li>饿汉模式</li>
</ol>
</li>
</ol>
<p>所谓饿汉模式就是立即加载，一般情况下再调用getInstancef方法之前就已经产生了实例，也就是在类加载的时候已经产生了。这种模式的缺点很明显，就是占用资源，当单例类很大的时候，其实我们是想使用的时候再产生实例。因此这种方式适合占用资源少，在初始化的时候就会被用到的类。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class SingletonHungary &#123;</span><br><span class="line">	private <span class="keyword">static</span> SingletonHungary singletonHungary <span class="operator">=</span> <span class="keyword">new</span> SingletonHungary();</span><br><span class="line">	<span class="operator">/</span><span class="operator">/</span>将构造器设置为private禁止通过<span class="keyword">new</span>进行实例化</span><br><span class="line">	private SingletonHungary() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public <span class="keyword">static</span> SingletonHungary getInstance() &#123;</span><br><span class="line">		<span class="keyword">return</span> singletonHungary;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>懒汉模式</li>
</ol>
<p>懒汉模式就是延迟加载，也叫懒加载。在程序需要用到的时候再创建实例，这样保证了内存不会被浪费。针对懒汉模式，这里给出了5种实现方式，有些实现方式是线程不安全的，也就是说在多线程并发的环境下可能出现资源同步问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 单例模式的懒汉实现<span class="number">1</span><span class="comment">--线程不安全</span></span><br><span class="line">class SingletonLazy1 &#123;</span><br><span class="line">	private <span class="keyword">static</span> SingletonLazy1 singletonLazy;</span><br><span class="line"></span><br><span class="line">	private SingletonLazy1() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> SingletonLazy1 getInstance() &#123;</span><br><span class="line">		if (<span class="keyword">null</span> <span class="operator">=</span><span class="operator">=</span> singletonLazy) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				<span class="operator">/</span><span class="operator">/</span> 模拟在创建对象之前做一些准备工作</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			singletonLazy <span class="operator">=</span> <span class="keyword">new</span> SingletonLazy1();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonLazy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 单例模式的懒汉实现<span class="number">2</span><span class="comment">--线程安全</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 通过设置同步方法，效率太低，整个方法被加锁</span><br><span class="line">class SingletonLazy2 &#123;</span><br><span class="line">	private <span class="keyword">static</span> SingletonLazy2 singletonLazy;</span><br><span class="line"></span><br><span class="line">	private SingletonLazy2() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> synchronized SingletonLazy2 getInstance() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			if (<span class="keyword">null</span> <span class="operator">=</span><span class="operator">=</span> singletonLazy) &#123;</span><br><span class="line">				<span class="operator">/</span><span class="operator">/</span> 模拟在创建对象之前做一些准备工作</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				singletonLazy <span class="operator">=</span> <span class="keyword">new</span> SingletonLazy2();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonLazy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 单例模式的懒汉实现<span class="number">3</span><span class="comment">--线程安全</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 通过设置同步代码块，效率也太低，整个代码块被加锁</span><br><span class="line">class SingletonLazy3 &#123;</span><br><span class="line"></span><br><span class="line">	private <span class="keyword">static</span> SingletonLazy3 singletonLazy;</span><br><span class="line"></span><br><span class="line">	private SingletonLazy3() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> SingletonLazy3 getInstance() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			synchronized (SingletonLazy3.class) &#123;</span><br><span class="line">				if (<span class="keyword">null</span> <span class="operator">=</span><span class="operator">=</span> singletonLazy) &#123;</span><br><span class="line">					<span class="operator">/</span><span class="operator">/</span> 模拟在创建对象之前做一些准备工作</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					singletonLazy <span class="operator">=</span> <span class="keyword">new</span> SingletonLazy3();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			<span class="operator">/</span><span class="operator">/</span> TODO: handle exception</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonLazy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 单例模式的懒汉实现<span class="number">4</span><span class="comment">--线程不安全</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 通过设置同步代码块，只同步创建实例的代码</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 但是还是有线程安全问题</span><br><span class="line">class SingletonLazy4 &#123;</span><br><span class="line"></span><br><span class="line">	private <span class="keyword">static</span> SingletonLazy4 singletonLazy;</span><br><span class="line"></span><br><span class="line">	private SingletonLazy4() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> SingletonLazy4 getInstance() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			if (<span class="keyword">null</span> <span class="operator">=</span><span class="operator">=</span> singletonLazy) &#123;        <span class="operator">/</span><span class="operator">/</span>代码<span class="number">1</span></span><br><span class="line">				<span class="operator">/</span><span class="operator">/</span> 模拟在创建对象之前做一些准备工作</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				synchronized (SingletonLazy4.class) &#123;</span><br><span class="line">					singletonLazy <span class="operator">=</span> <span class="keyword">new</span> SingletonLazy4(); <span class="operator">/</span><span class="operator">/</span>代码<span class="number">2</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			<span class="operator">/</span><span class="operator">/</span> TODO: handle exception</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonLazy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>单例模式的懒汉实现<span class="number">5</span><span class="comment">--线程安全</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>通过设置同步代码块，使用DCL双检查锁机制</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>使用双检查锁机制成功的解决了单例模式的懒汉实现的线程不安全问题和效率问题</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>DCL 也是大多数多线程结合单例模式使用的解决方案</span><br><span class="line">class SingletonLazy5 &#123;</span><br><span class="line"></span><br><span class="line">	private <span class="keyword">static</span> volatile SingletonLazy5 singletonLazy; <span class="operator">/</span><span class="operator">/</span> 注意这里的volatie关键字</span><br><span class="line"></span><br><span class="line">	private SingletonLazy5() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> SingletonLazy5 getInstance() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			if (<span class="keyword">null</span> <span class="operator">=</span><span class="operator">=</span> singletonLazy) &#123;</span><br><span class="line">				<span class="operator">/</span><span class="operator">/</span> 模拟在创建对象之前做一些准备工作</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				synchronized (SingletonLazy5.class) &#123;  <span class="operator">/</span><span class="operator">/</span>DCL双重检查锁机制</span><br><span class="line">					if(<span class="keyword">null</span> <span class="operator">=</span><span class="operator">=</span> singletonLazy) &#123;</span><br><span class="line">						singletonLazy <span class="operator">=</span> <span class="keyword">new</span> SingletonLazy5();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			<span class="operator">/</span><span class="operator">/</span> TODO: handle exception</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonLazy;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>静态内部类</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>使用静态内部类实现单例模式<span class="comment">--线程安全</span></span><br><span class="line">class SingletonStaticInner &#123;</span><br><span class="line">	private SingletonStaticInner() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	private <span class="keyword">static</span> class SingletonInner &#123;</span><br><span class="line">		private <span class="keyword">static</span> SingletonStaticInner singletonStaticInner <span class="operator">=</span> <span class="keyword">new</span> SingletonStaticInner();</span><br><span class="line">	&#125;</span><br><span class="line">	public <span class="keyword">static</span> SingletonStaticInner getInstance() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			<span class="operator">/</span><span class="operator">/</span> TODO Auto<span class="operator">-</span>generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> SingletonInner.singletonStaticInner;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>静态代码块 也是一种饿汉模式</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>使用静态代码块实现单例模式</span><br><span class="line">class SingletonStaticBlock &#123;</span><br><span class="line">	private <span class="keyword">static</span> SingletonStaticBlock singletonStaticBlock;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		singletonStaticBlock <span class="operator">=</span> <span class="keyword">new</span> SingletonStaticBlock();</span><br><span class="line">	&#125;</span><br><span class="line">	public <span class="keyword">static</span> SingletonStaticBlock getInstance() &#123;</span><br><span class="line">		<span class="keyword">return</span> singletonStaticBlock;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>序列化与反序列化</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonStaticInnerSerializeTest &#123;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">static</span> void main(String[] args) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			SingletonStaticInnerSerialize serialize <span class="operator">=</span> SingletonStaticInnerSerialize.getInstance();</span><br><span class="line">			System.out.println(serialize.hashCode());</span><br><span class="line">			<span class="operator">/</span><span class="operator">/</span>序列化</span><br><span class="line">			FileOutputStream fo <span class="operator">=</span> <span class="keyword">new</span> FileOutputStream(&quot;tem&quot;);</span><br><span class="line">			ObjectOutputStream oo <span class="operator">=</span> <span class="keyword">new</span> ObjectOutputStream(fo);</span><br><span class="line">			oo.writeObject(serialize);</span><br><span class="line">			oo.close();</span><br><span class="line">			fo.close();</span><br><span class="line">			<span class="operator">/</span><span class="operator">/</span>反序列化</span><br><span class="line">			FileInputStream fi <span class="operator">=</span> <span class="keyword">new</span> FileInputStream(&quot;tem&quot;);</span><br><span class="line">			ObjectInputStream oi <span class="operator">=</span> <span class="keyword">new</span> ObjectInputStream(fi);</span><br><span class="line">			SingletonStaticInnerSerialize serialize2 <span class="operator">=</span> (SingletonStaticInnerSerialize) oi.readObject();</span><br><span class="line">			oi.close();</span><br><span class="line">			fi.close();</span><br><span class="line">			System.out.println(serialize2.hashCode());</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>使用匿名内部类实现单例模式，在遇见序列化和反序列化的场景，得到的不是同一个实例</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>解决这个问题是在序列化的时候使用readResolve方法，即去掉注释的部分</span><br><span class="line">class SingletonStaticInnerSerialize implements Serializable &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 2018年03月28日</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	private <span class="keyword">static</span> <span class="keyword">final</span> long serialVersionUID <span class="operator">=</span> <span class="number">1</span>L;</span><br><span class="line">	</span><br><span class="line">	private <span class="keyword">static</span> class InnerClass &#123;</span><br><span class="line">		private <span class="keyword">static</span> SingletonStaticInnerSerialize singletonStaticInnerSerialize <span class="operator">=</span> <span class="keyword">new</span> SingletonStaticInnerSerialize();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public <span class="keyword">static</span> SingletonStaticInnerSerialize getInstance() &#123;</span><br><span class="line">		<span class="keyword">return</span> InnerClass.singletonStaticInnerSerialize;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>	protected Object readResolve() &#123;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>		System.out.println(&quot;调用了readResolve方法&quot;);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>		<span class="keyword">return</span> InnerClass.singletonStaticInnerSerialize;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>spring的事务与默认值</p>
</li>
</ol>
<p>① PROPAGATION_REQUIRED：（默认传播行为）如果当前没有事务，就创建一个新事务；如果当前存在事务，就加入该事务。<br>② PROPAGATION_REQUIRES_NEW：无论当前存不存在事务，都创建新事务进行执行。<br>③ PROPAGATION_SUPPORTS：如果当前存在事务，就加入该事务；如果当前不存在事务，就以非事务执行。‘<br>④ PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>⑤ PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则按REQUIRED属性执行。<br>⑥ PROPAGATION_MANDATORY：如果当前存在事务，就加入该事务；如果当前不存在事务，就抛出异常。<br>⑦ PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<ol start="4">
<li>快速排序的实现</li>
</ol>
<h3 id="上海蚁城科技"><a href="#上海蚁城科技" class="headerlink" title="上海蚁城科技"></a>上海蚁城科技</h3><p>笔试：<br><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/docx/35372544/1685361311885-d3337b96-061d-48e9-9a36-62f66d3f5301.docx?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2023/docx/35372544/1685361311885-d3337b96-061d-48e9-9a36-62f66d3f5301.docx%22,%22name%22:%22%E4%B8%8A%E6%B5%B7%E8%9A%81%E5%9F%8E%E7%A7%91%E6%8A%80.docx%22,%22size%22:13560,%22ext%22:%22docx%22,%22source%22:%22%22,%22status%22:%22done%22,%22download%22:true,%22taskId%22:%22u05d99887-2357-4814-b246-6c7f7177d6f%22,%22taskType%22:%22upload%22,%22type%22:%22application/vnd.openxmlformats-officedocument.wordprocessingml.document%22,%22__spacing%22:%22both%22,%22mode%22:%22title%22,%22id%22:%22ue4a92fff%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">上海蚁城科技.docx</a><br>技术面：<br><strong>git生产环境？</strong></p>
<p><strong>数据库建表的原则？</strong><br>三大范式：第一范式：所有字段不能再分。第二字段：其他属性必须完全依赖于主键。消除部分依赖。第三范式：确保没有传递依赖。<br><strong>Redis介绍？</strong><br>非关系型数据库，与MySQL数据库不同的是，Redis的数据是存在内存中的。它的读写速度非常快，每秒可以处理超过10万次读写操作。因此redis被<strong>广泛应用于缓存</strong>，单线程，但拥有多路复用，惰性删除。当查询的数据量过大时卡住主线程可能会导致系统崩溃。网络采用的多线程。另外，Redis也经常用来做分布式锁、排行榜（Zset）、计数器&#x2F;限速器，实现统计用户点赞功能以及商品秒杀的实现。（利用原子自增操作）。简单的消息队列（pub&#x2F;sub模型）等。<br><strong>死锁的产生和解决?</strong><br>定义：如果一个进程集合中的每个进程都在等待只能由此集合中的其他进程才能引发的事件，而无限期陷入僵持的局面称为死锁。<br><strong>产生条件：互斥条件、占有和等待条件、不剥夺条件、循环等待条件。</strong><br><strong>解决：破坏其中的一个条件就行。1、使资源能同时访问。2、进程执行之前就获取所有的资源。3、占有资源的进程要获取新的资源要释放原有资源或者当申请的资源被占用时剥夺已占有的资源使其进入等待队列。4、</strong>给系统的所有资源编号，规定进程请求所需资源的顺序必须按照资源的编号依次进行。<br>采用层次分配策略，将系统中所有的资源排列到不同层次中</p>
<ul>
<li>一个进程得到某层的一个资源后，只能申请较高一层的资源</li>
<li>当进程释放某层的一个资源时，必须先释放所占有的较高层的资源</li>
<li>当进程获得某层的一个资源时，如果想申请同层的另一个资源，必须先释放此层中已占有的资源</li>
</ul>
<p><strong>Mysql慢加载？</strong><br><strong>数据库中怎么将时间字符串转为时间？</strong></p>
<table>
<thead>
<tr>
<th>Date_Format()</th>
<th>返回一个格式化的日期或时间串</th>
</tr>
</thead>
</table>
<p><strong>自身的缺点？</strong><br>由于没有实习经验，因此对于企业的整体开发流程可能不是很清楚。同时性格比较腼腆，上台发言会容易紧张。但我每次我都会做好充分的准备去应对突发情况。<br><strong>为什么选自己不选其他人的理由?</strong><br>结合自我介绍进行回答。</p>
<h3 id="沈阳东数信息"><a href="#沈阳东数信息" class="headerlink" title="沈阳东数信息"></a>沈阳东数信息</h3><p>笔试+面试：<br><strong>自我介绍。</strong></p>
<ul>
<li><strong>怎么编写动态SQL？</strong></li>
</ul>
<p>动态SQL可以使用<if>、<where>、<set>等标签对参数进行过滤。原理使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<ul>
<li><strong>SQL中#与$的区别？</strong></li>
</ul>
<p>#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。$将传入的数据直接显示生成在sql中代替{}中的字符。</p>
<ul>
<li><strong>什么是单例模式？</strong></li>
</ul>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
<li><strong>反射的作用？</strong></li>
</ul>
<p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>
<ul>
<li><strong>什么是泛型，项目中什么地方使用到了泛型？</strong></li>
</ul>
<p>泛型可以分为泛型类、泛型接口、泛型方法。本质是类型化参数，编译期间确定类型，保证类型安全，放的是什么取得就是什么类型。合并了同类型的处理代码提高了代码的重用率，增加了程序的通用灵活性。<br>泛型通配符的上线和下限;<br>&lt;? extends T&gt; (上限)不可以添加元素，但可以取出类型为T的元素。 &lt;? super T&gt;（下限） 可以添加T或者T的子类，取出的一定是object类。<br>使用：在通用的返回类中使用到了泛型，用于存储返回的数据。</p>
<ul>
<li><strong>什么是接口，哪里用到了接口？</strong></li>
</ul>
<p>接口表示一个完全抽象类，其中的方法全为抽象方法。接口中的常量应该（默认）定义为public static final。接口算是一中规范，定义了实现该接口的类一定要实现这些方法。<br>使用：Fegin的远程调用。Service层。</p>
<ul>
<li><strong>项目中遇到了那些异常？</strong></li>
</ul>
<p>数据库中的数据与Redis中的数据不一致。使用分布式锁中的读写锁解决。使用延迟双删的策略解决数据更新时导致数据库中信息与Redis数据不一致问题。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Not_Look_Back/article/details/120208695">https://blog.csdn.net/Not_Look_Back&#x2F;article&#x2F;details&#x2F;120208695</a></p>
</blockquote>
<p>将安全认证单独设置一个模块，其他模块的权限问题怎么解决。<br>在其他的模块中增加一个自定义JWT的过滤器，将用户的权限进行封装。方便使用注解进行接口调用的权限管理。</p>
<p>解决：</p>
<h2 id="Java八股文"><a href="#Java八股文" class="headerlink" title="Java八股文"></a>Java八股文</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>位移运算：</p>
<ul>
<li>&lt;&lt;左移运算低位补0；</li>
<li><blockquote>
<blockquote>
<p>带符号右移:正数高位补0，负数补1</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>无符号右移，空位都以0补齐</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<p>当位移的位数大于数值所占的位数时，先将移动的位数与数值所占的位数取余，按余数位移。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &gt;&gt; <span class="number">42</span> == x &gt;&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>基本数据类型的成员变量如果没有被static修饰的话，就存放在堆中。</p>
<h3 id="逃逸技术"><a href="#逃逸技术" class="headerlink" title="逃逸技术"></a>逃逸技术</h3><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在《Java虚拟机规范》中，堆Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配”。其实这句话这样说也没有问题，但实际上，由于即时编译技术的进步，尤其是逃逸技术的发展，栈上内存、标量替换等优化手段使得对象的存储可以在堆中。<br>本文将通过该问题为引入点，重点介绍逃逸分析技术以及其对应的优化手段。</p>
<h2 id="逃逸分析技术"><a href="#逃逸分析技术" class="headerlink" title="逃逸分析技术"></a>逃逸分析技术</h2><p>逃逸分析技术是一直比较前沿的分析技术，他并不会直接优化代码，而是为其它代码优化手段提供依据。 逃逸分析可以将对象由高到底的不同逃逸程度分为三类：从不逃逸、方法逃逸、线程逃逸。</p>
<h3 id="线程逃逸"><a href="#线程逃逸" class="headerlink" title="线程逃逸"></a>线程逃逸</h3><p>如果一个线程内的对象有可能被其它线程访问到，那么这个对象就行线程逃逸的。</p>
<h3 id="方法逃逸"><a href="#方法逃逸" class="headerlink" title="方法逃逸"></a>方法逃逸</h3><p>如果一个对象在方法内部创建后，可能被其它方法所引用，例如通过参数传递给其它方法，又或者作为方法返回值返回给其它方法，这就叫方法逃逸</p>
<h3 id="从不逃逸"><a href="#从不逃逸" class="headerlink" title="从不逃逸"></a>从不逃逸</h3><p>如果一个对象在方法内部创建后，不可能被其它方法所引用，也不可能被其它线程所引用，那么它就是从不逃逸的。</p>
<h3 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h3><p>根据逃逸分析技术得出的对象分析情况，我们可以对不同逃逸程度的对象采取不同程度的优化。</p>
<h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>首先我们来明确下堆和栈的区别。对于堆来说，它是所有线程所共享的，存在垃圾回收机制。而对于栈来说，每个线程都有自己的虚拟机栈，而线程每执行一个方法就会在栈中创建一个栈帧，方法调用结束相应的栈帧会被销毁，当线程结束运行时对应的栈也会被销毁，所以说栈是不需要垃圾回收的。<br>而正如我们开头说的，对象实例以及数组应当在堆上分配。并且由于堆对于所有线程是共享的，所以说只要线程持有某对象的引用，就可以使用该对象。而当一个对象不会再被使用的时候，就会通过垃圾回收机制进行回收，然后垃圾回收其实是要浪费很多资源的。而对于不会发生线程逃逸的对象来说，它是不需要线程共享使用的，那么将这个对象在栈上分配内存或许会更好一些，因为对于栈来说它占用的空间是可以随着栈帧出栈而销毁的，就不需要通过垃圾回收机制进行回收。<br>也就是说，对这种不会发生线程逃逸的对象，在栈空间上分配内存的情况，就叫栈上分配。而不会发生线程逃逸的对象占比是很高的，如果可以采用栈上分配的方式，那么垃圾回收系统的压力就会小很多。</p>
<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><h5 id="标量和聚合量"><a href="#标量和聚合量" class="headerlink" title="标量和聚合量"></a>标量和聚合量</h5><p>首先介绍下标量和聚合量：</p>
<ul>
<li>标量就是指那些已经无法再分分解为更小数据来表示的数据，比如Java虚拟机中的原始数据（int、double等）。</li>
<li>如标量相反，如果一个数据可以被分解为更小的数据，难么它就是聚合量，比如对象就是一种典型的聚合量。</li>
</ul>
<h5 id="标量替换-1"><a href="#标量替换-1" class="headerlink" title="标量替换"></a>标量替换</h5><p>那所谓的标量替换，就是在某些情况下，将聚合量拆分为多个标量，即将一个对象根据程序的访问情况，将其用到的成员变量恢复为原始类型来访问的过程。<br>引用周志明老师《深入理解JVM虚拟机》中的一段话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line">复制代码假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可拆散，那么程序真正执行的时候将可能不去创建这个</span><br><span class="line">对象，而改为直接创建它的诺干个被这个方法使用的成员变量来代替，将对象拆分后，除了可以让对象的成员变量在栈上（</span><br><span class="line">栈上存储的数据，很大机会会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写外，还可以为后续进一步的优化创</span><br><span class="line">造条件。</span><br></pre></td></tr></table></figure>
<p>标量替换可以看作栈上分配的一种特殊情况，但是标量替换是不允许方法逃逸的，而栈上分配接收方法逃逸且不接受线程逃逸。</p>
<h4 id="同步消除"><a href="#同步消除" class="headerlink" title="同步消除"></a>同步消除</h4><p>如果你有了解过并发编程，那么应该清楚，当一个变量可以被多个线程同时访问时，那么就可能会存在线程安全问题。这时候我们往往会采取一些同步措施来预防安全问题。<br>但是，如果我们通过逃逸技术分析得到一个对象是不会发生线程逃逸的，又因为单核CPU同时只能执行一条指令，所以该对象一定是线程安全的，所以我们为该对象加的同步措施就可以安全的消除掉（同步措施往往会消耗很多资源），这就叫同步消除。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文主要介绍了逃逸分析技术以及其对应的优化。而实际上，逃逸分析的计算成本往往是非常高的，很多时候我们并不能保证逃逸分析带来的收益会高于其消耗，所以目前的虚拟机只能采用不那么准确、相对简单的算法进行逃逸分析。<br>另外，回到我们题目中的问题，因为有了栈上分配和标量替换的存在，使得并不是所有对象实例都会分配到堆中，更准确的说法应该是：几乎所有的对象实例都会分配到堆中。</p>
<h3 id="Java类加载顺序"><a href="#Java类加载顺序" class="headerlink" title="Java类加载顺序"></a>Java类加载顺序</h3><p>一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生。</p>
<ol>
<li>准备加载类</li>
<li>静态变量和静态代码块的加载顺序由编写的先后顺序决定</li>
<li>new一个类，但在new之前要处理匿名代码块</li>
<li>按顺序加载变量和代码</li>
<li>加载构造函数，完成对象的创建</li>
</ol>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h4><p>Byte，Short,Integer,Long这四种包装类默认创建了数值[-128,127]的对应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean直接返回True或False。<br><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>被final修饰的成员变量与局部变量不会自动赋值，必须显性的赋值。</p>
<p>被final修饰的变量初始化之后不能改变其值。final修饰的对相关类型数据，对象中的数据可以修改，只是说不能再引用其他的对象。<br><strong>对于final和static</strong><br>两者作用于变量作用并不相同，最主要区别在于：final保证变量不可变，static表示只对变量保存一份副本<br>final声明的常量分为<strong>编译期常量</strong>和<strong>运行时常量</strong><br>  <strong>编译期常量</strong>：如果在编译时，final变量是基本类型或String类型，且jvm可以确定它的确切值，那么编译器会把它当做编译期常量使用，<strong>使用字面量替换并存入class常量池，在需要它的时候，直接访问这个常量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String q=<span class="string">&quot;b&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>运行时常量</strong>：即并不直接用字面量为final常量赋值，中间经过引用或获取的过程（可以是对局部变量的获取或某些处理过程结果的获取）最开始并没有确切额值，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="string">&quot;sjt&quot;</span>.length();</span><br></pre></td></tr></table></figure>
<p>  <strong>编译期常量在</strong>编译阶段存入class常量池，不引起类的初始化，<strong>即不依赖类</strong><br>  <strong>运行时常量依赖类</strong>，会引起类的初始化（类立即执行）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子（1）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="comment">//静态代码块</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">  	System.out.println(<span class="string">&quot;Class Test Was Loaded!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//编译期常量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;	</span><br><span class="line">  <span class="comment">//运行时常量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="string">&quot;Rhien&quot;</span>.length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  	System.out.println(<span class="string">&quot;num:&quot;</span>+Test.num);</span><br><span class="line">  	System.out.println(<span class="string">&quot;=== after get num ===&quot;</span>);</span><br><span class="line">  	System.out.println(<span class="string">&quot;len:&quot;</span>+Test.len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 打印输出:</span></span><br><span class="line"><span class="comment">* num:10</span></span><br><span class="line"><span class="comment">* === after get num ===</span></span><br><span class="line"><span class="comment">* Class Test Was Loaded!</span></span><br><span class="line"><span class="comment">* len:5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>编译期常量可直接使用的探讨</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello2&quot;</span>; </span><br><span class="line">      <span class="keyword">final</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> b + <span class="number">2</span>; </span><br><span class="line">      <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> d + <span class="number">2</span>;</span><br><span class="line">      System.out.println((a == c));</span><br><span class="line">      System.out.println((a == e));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果为：</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于b来说，在编译期已经被字面量“hello”替换，其值存入了class常量池，那么对于c的等式而言，在编译期中“+”左右两边均为字符串常量，jvm在编译期直接将其相连并确定了c的值存入常量池中；对e来说，“+”两边存在变量，那么对java而言，会new一个StringBuilder来进行拼接（具体细节自行查阅），此时用到了new，那么e的值被放在了堆中，a与e的地址当然不同，故flase。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h4><p><strong>1、调用方式</strong><br>在外部调用静态方法时，可以使用 类名.方法名 的方式，也可以使用 对象.方法名 的方式（经测试后发现会报错），而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。<br>不过，需要注意的是一般不建议使用 对象.方法名 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。<br>因此，一般建议使用 类名.方法名 的方式来调用静态方法。</p>
<h4 id="方法的重写要遵循“两同两小一大”（外盒不变，内核改变）"><a href="#方法的重写要遵循“两同两小一大”（外盒不变，内核改变）" class="headerlink" title="方法的重写要遵循“两同两小一大”（外盒不变，内核改变）"></a>方法的重写要遵循“两同两小一大”（外盒不变，内核改变）</h4><ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。<br>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。<br>最常用的地方就是构造器的重载。<br><strong>重载规则:</strong></p>
<ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
<h4 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h4><p>可变参数只能作为函数的最后一个参数。编译之后实际会被转换成一个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    testAuto(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hncu&quot;</span>,<span class="string">&quot;word&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAuto</span><span class="params">(String ...str)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(String s:str) &#123;  </span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(str[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong><br>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VariableLengthArgument</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : args) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printVariable</span><span class="params">(String arg1, String arg2)</span> &#123;</span><br><span class="line">        System.out.println(arg1 + arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        printVariable(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ab</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><p>new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<ul>
<li>一个对象引用可以指向0个或1个对象实例；</li>
<li>一个对象可以有n个引用指向他。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改前：&quot;</span>+<span class="string">&quot;p1:&quot;</span>+p.getAge()+<span class="string">&quot;   p2:&quot;</span>+p2.getAge());</span><br><span class="line">        p1.setAge(<span class="number">23</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后：&quot;</span>+<span class="string">&quot;p1:&quot;</span>+p.getAge()+<span class="string">&quot;   p2:&quot;</span>+p2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改前：p1:<span class="number">0</span>   p2:<span class="number">0</span></span><br><span class="line">修改后：p1:<span class="number">23</span>   p2:<span class="number">23</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h4><p><strong>封装：</strong> 封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了<br><strong>继承：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式重写父类的方法。</li>
</ol>
<p><strong>多态：</strong>具体变现为父类引用指向子类的实例。</p>
<ul>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">成员访问特点:</span><br><span class="line">    成员变量</span><br><span class="line">        编译看左边，运行看左边</span><br><span class="line">    成员方法</span><br><span class="line">        编译看左边，运行看右边</span><br><span class="line">    静态方法</span><br><span class="line">        编译看左边，运行看左边</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h4><p><strong>共同点</strong>：</p>
<ul>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>
</ul>
<hr>
<h4 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h4><p>关于深拷贝和浅拷贝区别，我这里先给结论：</p>
<ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
</ul>
<p><strong>浅拷贝：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>深拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<h4 id="重写equals"><a href="#重写equals" class="headerlink" title="重写equals"></a>重写equals</h4><p>重写equals需要遵循Java如下规则：</p>
<ol>
<li><p>自反性：对于任意的对象x，x.equals(x)返回true(自己一定等于自己)；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对称性：对于任意的对象x和y，若x.equals(y)为true，则y.equals(x)亦为true；</p>
</li>
<li><p>传递性：对于任意的对象x、y和z，若x.equals(y)为true且y.equals(z)也为true，则x.equals(z)亦为true；</p>
</li>
<li><p>一致性：对于任意的对象x和y，x.equals(y)的第一次调用为true，那么x.equals(y)的第二次、第三次、第n次调用也均为true，前提条件是没有修改x也没有修改y；</p>
</li>
<li><p>对于非空引用x，x.equals(null)永远返回为false。</p>
</li>
</ol>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="StringBuffer中的capacity的扩增机制"><a href="#StringBuffer中的capacity的扩增机制" class="headerlink" title="StringBuffer中的capacity的扩增机制"></a>StringBuffer中的capacity的扩增机制</h4><pre><code>StringBuffer大家一定不陌生吧，今天浅谈一下StringBuffer中capacity的扩增机制。
因为StringBuffer实际通过一个char[]引用来保存字符串的，它的长度是固定的。
如果append的值超过了数组容量，将会执行一个扩容方法，生成一个新数组，并将旧数组的值copy进去并替代。
</code></pre>
<p><strong>为什么说StringBuffer是安全的？</strong><br>StringBuffer很多方法都是synchronized修饰的。</p>
<blockquote>
<p>capacity增长的规律为 旧值*2+2</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot; Hello World!!! &quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot; this capacity: &quot;</span> + sb1.capacity());</span><br><span class="line">System.out.println(<span class="string">&quot; this length: &quot;</span> + sb1.length());</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb2.append(<span class="string">&quot; Hello World!!! &quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot; this capacity: &quot;</span> + sb2.capacity());</span><br><span class="line">System.out.println(<span class="string">&quot; this length: &quot;</span> + sb2.length());</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span> capacity: <span class="number">32</span></span><br><span class="line"><span class="built_in">this</span> length: <span class="number">16</span></span><br><span class="line"><span class="built_in">this</span> capacity: <span class="number">16</span></span><br><span class="line"><span class="built_in">this</span> length: <span class="number">16</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">   <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;  <span class="comment">//在传入的字符串长度再加上16</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> ensureCapacityInternal(count + len);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implements the expansion semantics of ensureCapacity with no</span></span><br><span class="line"><span class="comment"> * size check or synchronization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">expandCapacity</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> value.length * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//如果minimumCapacity大于原容量*2+2</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minimumCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        newCapacity = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么说String类型不可变？"><a href="#为什么说String类型不可变？" class="headerlink" title="为什么说String类型不可变？"></a>为什么说String类型不可变？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>

<ul>
<li>String的源码里其实使用一个char数组来存储字符串的，<strong>String之所以说不可变，就是因为这个char数组它是private类型，而且String没有对外暴露和提供修改这个char数组的方法，因此我们无法更改这个char数组的值，所以String是不可变的</strong>。</li>
<li><strong>注意</strong>：这里char数组被final修饰<strong>不代表不可变</strong>，因为数组是引用类型，final修饰引用类型的时候代表引用不可更改，即我们<strong>只是不能将这个value属性指向新的引用</strong>，但是<strong>它原本指向的这个char数组中的字符我们是可以更改的</strong>。</li>
</ul>
<h4 id="String-intern-方法有什么作用"><a href="#String-intern-方法有什么作用" class="headerlink" title="String#intern 方法有什么作用?"></a>String#intern 方法有什么作用?</h4><p>String.intern() 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p>
<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li>
<li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>; <span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;  <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong><br>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。《深入理解 Java 虚拟机》中是也有介绍到：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1685171987855-bf65b233-a5c9-485e-8864-fba451e3c687.png" alt="image.png"><br>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。<br>对于 String str3 &#x3D; “str” + “ing”; 编译器会给你优化成 String str3 &#x3D; “string”; 。<br>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ul>
<li>基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。</li>
<li>final 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
<p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p>
<p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。<br>不过，字符串使用 final 关键字声明之后，可以让编译器当做常量来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1685173982023-02eb2f66-aba0-4923-aadb-5e2dfd60242d.png" alt="异常类图"></p>
<h4 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h4><ul>
<li>Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。</li>
<li>Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</li>
<li>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、ClassNotFoundException、SQLException…。</li>
</ul>
<h4 id="try-with-resources语句"><a href="#try-with-resources语句" class="headerlink" title="try-with-resources语句"></a>try-with-resources语句</h4><p>_try-with-resources的_另一个好方面是添加&#x2F;删除我们正在使用_的资源_的简便性，同时确保在完成后它们将被关闭。<br>如果要使用多个文件，则可以在<strong>try()<strong>语句中打开文件，并用分号将它们分开：类似于将资源操作当做一个参数传入，try语句执行完毕之后会自动调用</strong>close</strong>语句。<br>声明的所有资源try()必须实现该AutoCloseable接口。这些通常是各种类型的编写器，读取器，套接字，输出或输入流等<br><strong>关闭资源和 finally 块的执行顺序：</strong> 在 try-with-resources 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/docx/35372544/1685194601432-3d7d8909-f94b-4bfc-9e89-c620c5ba95d2.docx">14_反射.docx</a><br>反射：就是通过class文件对象，去使用该文件中的成员变量，构造方法，成员方法。<br>JDK实现动态代理就是使用了反射类Method来调用指定的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="获取Class对象的四种方式："><a href="#获取Class对象的四种方式：" class="headerlink" title="获取Class对象的四种方式："></a>获取Class对象的四种方式：</h4><p><strong>1. 知道具体类的情况下可以使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class;</span><br></pre></td></tr></table></figure>

<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化<br><strong>2. 通过 Class.forName()传入类的全路径获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>3. 通过对象实例instance.getClass()获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br></pre></td></tr></table></figure>

<p><strong>4. 通过类加载器xxxClassLoader.loadClass()传入类路径获取:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行</p>
<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。<br>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>
<h4 id="SPI与API"><a href="#SPI与API" class="headerlink" title="SPI与API"></a>SPI与API</h4><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1685198002380-904bba31-2ade-414f-88d9-0dbd02e516c8.png" alt="image.png"></p>
<p>一般模块之间都是通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。<br>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。<br>当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。<br>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。<br>     Java 中的 SPI 机制就是在每次类加载的时候会先去找到 class 相对目录下的 META-INF 文件夹下的 services 文件夹下的文件，将这个文件夹下面的所有文件先加载到内存中，然后根据这些文件的文件名和里面的文件内容找到相应接口的具体实现类，找到实现类后就可以通过反射去生成对应的对象，保存在一个 list 列表里面，所以可以通过迭代或者遍历的方式拿到对应的实例对象，生成不同的实现。<br>所以会提出一些规范要求：文件名一定要是接口的全类名，然后里面的内容一定要是实现类的全类名，实现类可以有多个，直接换行就好了，多个实现类的时候，会一个一个的迭代加载。<br>SPI 机制的具体实现本质上还是通过反射完成的。即：<strong>我们按照规定将要暴露对外使用的具体实现类在 META-INF&#x2F;services&#x2F; 文件下声明。</strong></p>
<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><ul>
<li><strong>序列化</strong>：将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<h4 id="序列化协议对应于-TCP-x2F-IP-4-层模型的哪一层？"><a href="#序列化协议对应于-TCP-x2F-IP-4-层模型的哪一层？" class="headerlink" title="序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层？"></a>序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层？</h4><ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686061799387-e3320b7b-1790-4429-9227-b5a64d105244.png" alt="TCP/IP四层模型"></p>
<h4 id="规定某些字段不进行序列化"><a href="#规定某些字段不进行序列化" class="headerlink" title="规定某些字段不进行序列化"></a>规定某些字段不进行序列化</h4><p>使用transient修饰符修饰。<br>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。<br>关于 transient 还有几点注意：</p>
<ul>
<li>transient 只能修饰变量，不能修饰类和方法。</li>
<li>transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。</li>
<li>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</li>
</ul>
<h4 id="为什么不推荐使用-JDK-自带的序列化？"><a href="#为什么不推荐使用-JDK-自带的序列化？" class="headerlink" title="为什么不推荐使用 JDK 自带的序列化？"></a>为什么不推荐使用 JDK 自带的序列化？</h4><p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p>
<ul>
<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
<li><strong>存在安全问题</strong>：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码</li>
</ul>
<h3 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h3><p>数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。<br>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h3 id="Java代理模式"><a href="#Java代理模式" class="headerlink" title="Java代理模式"></a>Java代理模式</h3><p>简单的说就是我们使用代理对象来代替对真实对象的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。<br><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong><br><strong>代理模式主要有静态代理和动态代理两种实现方式。</strong></p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理中的每个方法的增强都是手动完成的，，使用场景非常少。<br>实现步骤：</p>
<ol>
<li>定义一个接口或实现类；</li>
<li>创建一个代理类同样实现这个接口；</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标方法中的对应犯法，这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并在目标方法执行的前后做一些自己想做的事情。</li>
</ol>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsProxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsProxy</span><span class="params">(SmsService smsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smsService = smsService;a</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        <span class="type">SmsProxy</span> <span class="variable">smsProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsProxy</span>(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before method <span class="title function_">send</span><span class="params">()</span></span><br><span class="line">send message:java</span><br><span class="line">after method <span class="title function_">send</span><span class="params">()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>从JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到JVM中的<br>在Java中，常见的实现方式有JDK动态代理，CGLIB动态代理等。</p>
<h5 id="JDK代理机制："><a href="#JDK代理机制：" class="headerlink" title="JDK代理机制："></a>JDK代理机制：</h5><p><strong>在 Java 动态代理机制中 InvocationHandler 接口和 Proxy 类是核心。</strong><br>Proxy 类中使用频率最高的方法是：newProxyInstance() ，这个方法主要用来生成一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                          InvocationHandler h)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共有 3 个参数：</p>
<ul>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 InvocationHandler 接口的对象；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;  <span class="comment">//定义接口</span></span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123; <span class="comment">//实现接口</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123; 定义一个JDK动态代理类</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//proxy 动态生成的代理</span></span><br><span class="line"><span class="comment">//method 与代理类对象调用的方法相对应</span></span><br><span class="line"><span class="comment">//args 当前method方法的参数</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;  <span class="comment">//获取代理对象的工厂类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><p>JDK代理有一个最大的缺点，只能代理实现了接口的类；而CGLIB可以避免。<br><a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIBopen in new window</a>(<em>Code Generation Library</em>)是一个基于<a target="_blank" rel="noopener" href="http://www.baeldung.com/java-asm">ASMopen in new window</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIBopen in new window</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<blockquote>
<p>ASM：ASM是一种通用Java字节码操作和分析框架。它可以用于修改现有的class文件或动态生成class文件。<br>而CGLIB相当于是对ASM的进一步包装，简化了ASM的操作。</p>
</blockquote>
<p><strong>在 CGLIB 动态代理机制中 MethodInterceptor 接口和 Enhancer 类是核心。</strong><br>不同于 JDK 动态代理不需要额外的依赖。<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIBopen in new window</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line">public class AliSmsService &#123;</span><br><span class="line">    public String send(String message) &#123;</span><br><span class="line">        System.out.println(&quot;send message:&quot; + message);</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义MethodInterceptor</span><br><span class="line"> */</span><br><span class="line">public class DebugMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param o           被代理的对象（需要增强的对象）</span><br><span class="line">     * @param method      被拦截的方法（需要增强的方法）</span><br><span class="line">     * @param args        方法入参</span><br><span class="line">     * @param methodProxy 用于调用原始方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        //调用方法之前，我们可以添加自己的操作</span><br><span class="line">        System.out.println(&quot;before method &quot; + method.getName());</span><br><span class="line">        Object object = methodProxy.invokeSuper(o, args);</span><br><span class="line">        //调用方法之后，我们同样可以添加自己的操作</span><br><span class="line">        System.out.println(&quot;after method &quot; + method.getName());</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line">public class CglibProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Object getProxy(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">        // 创建动态代理增强类</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        // 设置类加载器</span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        // 设置被代理类</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        // 设置方法拦截器</span><br><span class="line">        enhancer.setCallback(new DebugMethodInterceptor());</span><br><span class="line">        // 创建代理类</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(&quot;java&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>

<p><strong>二者优缺点分析</strong><br>使用JDK动态代理，目标类必须实现的某个接口，如果某个类没有实现接口则不能生成代理对象。<br>Cglib原理是针对目标类生成一个子类，覆盖其中的所有方法，所以目标类和方法不能声明为final类型。<br>从执行效率上看，Cglib动态代理效率较高。</p>
<h3 id="BigDecimal的用处"><a href="#BigDecimal的用处" class="headerlink" title="BigDecimal的用处"></a>BigDecimal的用处</h3><p>《阿里巴巴Java开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用&#x3D;&#x3D;来比较，包装数据类型不能用 equals 来判断。</strong> </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float a = 1.0f - 0.9f;</span><br><span class="line">float b = 0.9f - 0.8f;</span><br><span class="line">System.out.println(a);// 0.100000024</span><br><span class="line">System.out.println(b);// 0.099999964</span><br><span class="line">System.out.println(a == b);// false</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = new BigDecimal(&quot;1.0&quot;);</span><br><span class="line">BigDecimal b = new BigDecimal(&quot;0.9&quot;);</span><br><span class="line">System.out.println(a.add(b));// 1.9</span><br><span class="line">System.out.println(a.subtract(b));// 0.1</span><br><span class="line">System.out.println(a.multiply(b));// 0.90</span><br><span class="line">System.out.println(a.divide(b));// 无法除尽，抛出 ArithmeticException 异常</span><br><span class="line">System.out.println(a.divide(b, 2, RoundingMode.HALF_UP));// 1.11</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 这里需要注意的是，在我们使用 divide 方法的时候尽量使用 3 个参数版本，并且RoundingMode 不要选择 UNNECESSARY，否则很可能会遇到 ArithmeticException（无法除尽出现无限循环小数的时候），其中 scale 表示要保留几位小数，roundingMode 代表保留规则。</p>
<h3 id="Java-魔法类-Unsafe-详解"><a href="#Java-魔法类-Unsafe-详解" class="headerlink" title="Java 魔法类 Unsafe 详解"></a>Java 魔法类 Unsafe 详解</h3><p>Unsafe主要提供一些用于执行低级别、不安全操作的方法。其拥有类似于C语言指针一样的操作内存空间的能力。<br>此外Unsafe类提供的这些功能实现需要依赖本地方法。<br><strong>创建</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final class Unsafe &#123;</span><br><span class="line">  // 单例对象</span><br><span class="line">  private static final Unsafe theUnsafe;</span><br><span class="line">  ......</span><br><span class="line">  private Unsafe() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  @CallerSensitive</span><br><span class="line">  public static Unsafe getUnsafe() &#123;</span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    // 仅在引导类加载器`BootstrapClassLoader`加载时才合法</span><br><span class="line">    if(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">      throw new SecurityException(&quot;Unsafe&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>注意：虽然getUnsafe（）方法为public static修饰的，但由于Unsafe的功能偏底层，所以对于安全性的要求更高。只能启动类加载器加载的类才能调用Unsafe类中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title function_">reflectGetUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredFiled(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        field.setAccessibe(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage(),e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h3><p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。</p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>通常情况下编译器处理泛型的方式有两种方式：Code specialization 和 Code sharing。<br>C++ 和 C# 是使用的Code specializaiton的处理机制，而Java采用的Code sharing；</p>
<blockquote>
<p> Code sharing 方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasue）实现的。</p>
</blockquote>
<p>上界 &lt;? extend Fruit&gt; ，表示所有继承Fruit的子类，但是具体是哪个子类，无法确定，所以调用add的时候，要add什么类型，谁也不知道。但是get的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是Fruit，所以，我都可以用最大的父类Fruit接着，也就是把所有的子类向上转型为Fruit。（只能取不能存）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般我们使用List&lt;Fruit&gt; plate = new ArrayList&lt;Apple&gt;(); 会出现错误</span></span><br><span class="line">但通过泛型的上界</span><br><span class="line">List&lt;? extend Fruit&gt; plate = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Apple&gt;(); 可以解决这个问题</span><br><span class="line">但正因为这个原因我们的泛型上界不能添加，因为我们不能确定我们存入的类型的确定值。</span><br></pre></td></tr></table></figure>

<p>只能在初始化时存入数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; plate = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Apple</span>(), <span class="keyword">new</span> <span class="title class_">Banana</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">Fruit</span> <span class="variable">apple</span> <span class="operator">=</span> plate.get(<span class="number">0</span>);</span><br><span class="line"><span class="type">Fruit</span> <span class="variable">banana</span> <span class="operator">=</span> plate.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>下界 &lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我add的时候，我不能add Apple的父类，因为不能确定List里面存放的到底是哪个父类。但是我可以add Apple及其子类。因为不管我的子类是什么类型，它都可以向上转型为Apple及其所有的父类甚至转型为Object 。但是当我get的时候，Apple的父类这么多，我用什么接着呢，除了Object，其他的都接不住。（能存，但取出的对象一般都是Object）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> Apple&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Fruit&gt;();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7022581523048038408">https://juejin.cn/post/7022581523048038408</a></p>
</blockquote>
<p>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。具体来讲，我可以把Apple对象赋值给Fruit的引用，但是如果把Fruit对象赋值给Apple的引用就必须得用cast。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jonathan</span> <span class="keyword">extends</span> <span class="title class_">Apple</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CovariantArrays</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">//上界</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; flistTop = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Apple&gt;();</span><br><span class="line">    flistTop.add(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//add Fruit对象会报错</span></span><br><span class="line">    <span class="comment">//flist.add(new Fruit());</span></span><br><span class="line">    <span class="type">Fruit</span> <span class="variable">fruit1</span> <span class="operator">=</span> flistTop.get(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//下界</span></span><br><span class="line">    List&lt;? <span class="built_in">super</span> Apple&gt; flistBottem = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Apple&gt;();</span><br><span class="line">    flistBottem.add(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line">    flistBottem.add(<span class="keyword">new</span> <span class="title class_">Jonathan</span>());</span><br><span class="line">    <span class="comment">//get Apple对象会报错</span></span><br><span class="line">    <span class="comment">//Apple apple = flistBottem.get(0);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>在我们的代码中，我们经常需要验证某些可能阻止应用程序正常工作的条件。通常我们会这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> getConnection();</span><br><span class="line"><span class="keyword">if</span>(conn == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Connection is null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用断言，我们可以用一个_assert_语句来代替_if_和_throw_语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> getConnection();</span><br><span class="line">    <span class="keyword">assert</span> conn != <span class="literal">null</span> : <span class="string">&quot;Connection is null&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> getConnection();</span><br><span class="line">    <span class="keyword">assert</span> conn != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686108518111-a6a3bb1b-4b90-4c5a-a0e6-2c8137ee1401.png#averageHue=%23f3f1ee&clientId=uf7a54a15-b4cc-4&from=paste&id=HAcru&originHeight=762&originWidth=1734&originalType=url&ratio=1.25&rotation=0&showTitle=true&size=142930&status=done&style=none&taskId=uc5c90dc2-fe1f-4a1e-929b-97245d9fe65&title=%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6" alt="集合框架" title="集合框架"><br>List</p>
<ul>
<li>ArrayList：Object[] 数组</li>
<li>Vector：Object[] 数组</li>
<li>LinkedList：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<p> Set</p>
<ul>
<li>HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>
<li>LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的</li>
<li>TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)</li>
</ul>
<p>Queue</p>
<ul>
<li>PriorityQueue: Object[] 数组来实现二叉堆</li>
<li>ArrayQueue: Object[] 数组 + 双指针</li>
</ul>
<p>再来看看 Map 接口下面的集合。<br>Map</p>
<ul>
<li>HashMap：JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a></li>
<li>Hashtable：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的，由于许多方法都是由synchronized修饰的，所以这是一个线程安全的类；</li>
<li>TreeMap：红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="LinkedList 为什么不能实现 RandomAccess 接口？"></a>LinkedList 为什么不能实现 RandomAccess 接口？</h4><p>RandomAccess 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 LinkedList 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 RandomAccess 接口。</p>
<h4 id="ArrayList与LinkedList区别？"><a href="#ArrayList与LinkedList区别？" class="headerlink" title="ArrayList与LinkedList区别？"></a>ArrayList与LinkedList区别？</h4><ul>
<li>两者都不保证线程安全</li>
<li>ArrayList底层使用的是数组，LinkedList采用的双向链表</li>
<li>插入和删除是否受元素位置影响<ul>
<li>ArrayList无论是在哪个位置插入和删除都会受影响</li>
<li>LinkedList只有在指定位置插入和删除才会受影响</li>
</ul>
</li>
<li>是否支持快速随机访问：ArrayList实现了RandomlAccess接口，支持随机访问</li>
<li>内存空间占用：ArrayList会在结尾预留一定空间，LinkedList：会存放直接前驱和直接后继以及数据因此空间的浪费会更大。</li>
</ul>
<p><strong>项目中一般不会使用LinkedList。</strong></p>
<h4 id="RandomAccess接口"><a href="#RandomAccess接口" class="headerlink" title="RandomAccess接口"></a>RandomAccess接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RandomAccess</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="Comparable与Comparator区别"><a href="#Comparable与Comparator区别" class="headerlink" title="Comparable与Comparator区别"></a>Comparable与Comparator区别</h4><ul>
<li>comparator一般用于工具类的比较器。重写compare(Object  obj1,Object obj2)</li>
<li>comparable一般用于自定义对象时实现。重写compareTo（Object obj）可以根据单词含义记忆。</li>
</ul>
<h4 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h4><ul>
<li>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="Queue与Deque的区别"><a href="#Queue与Deque的区别" class="headerlink" title="Queue与Deque的区别"></a>Queue与Deque的区别</h4><ul>
<li>Queue 扩展了Collection的接口，是单端队列，只能另一端插入元素，lingyidaun删除元素，实际上遵循FIFO规则</li>
<li>Deque 扩展了Queue接口，增加了在队首和队尾进行插入和删除的方法。</li>
</ul>
<p>Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈。</p>
<h4 id="什么是BlokingQueue"><a href="#什么是BlokingQueue" class="headerlink" title="什么是BlokingQueue"></a>什么是BlokingQueue</h4><p>BlockingQueue阻塞的原因是其支持当队列没有元素时一直阻塞，直到有有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。  一般常用于生产者消费者模型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1685520348450-a1d6e4e8-a385-449e-8d4c-4432beeaaeeb.png" alt="BlockingQueue的实现类"><br>Java 中常用的阻塞队列实现类有以下几种：</p>
<ol>
<li>ArrayBlockingQueue：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</li>
<li>LinkedBlockingQueue：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue类似， 它也支持公平和非公平的锁访问机制。</li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。元素必须实现Comparable接口或者在构造函数中传入Comparator对象，并且不能插入 null 元素。</li>
<li>SynchronousQueue：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，SynchronousQueue通常用于线程之间的直接传递数据。</li>
<li>DelayQueue：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li>
</ol>
<blockquote>
<p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。<br>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁</p>
</blockquote>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap与HashTable区别"><a href="#HashMap与HashTable区别" class="headerlink" title="HashMap与HashTable区别"></a>HashMap与HashTable区别</h4><ul>
<li>线程安全：HashMap 是非线程安全的，Hashtable 是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）</li>
<li>对Null key与Null value的支持：HashTable不允许有null键和值的存在</li>
<li><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。Hashtable 没有这样的机制。</li>
</ul>
<h4 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复?"></a>HashSet 如何检查重复?</h4><p> 当你把对象加入HashSet时，HashSet 会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns: true if this set did not already contain the specified element</span></span><br><span class="line"><span class="comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h4><p> JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 hashcode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<blockquote>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。<br>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
</blockquote>
<p>JDK1.8 之后相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h4 id="HashMap-的长度为什么是-2-的幂次"><a href="#HashMap-的长度为什么是-2-的幂次" class="headerlink" title="HashMap 的长度为什么是 2 的幂次"></a>HashMap 的长度为什么是 2 的幂次</h4><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。<br><strong>这个算法应该如何设计呢？</strong><br>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p>
<h4 id="JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？"><a href="#JDK-1-7-和-JDK-1-8-的-ConcurrentHashMap-实现有什么不同？" class="headerlink" title="JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？"></a>JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</h4><ul>
<li><strong>线程安全实现方式</strong>：JDK 1.7 采用 Segment 分段锁来保证安全(锁住部分数据)， Segment 是继承自 ReentrantLock。JDK1.8 放弃了 Segment 分段锁的设计，采用 Node + CAS + synchronized 保证线程安全，锁粒度更细，synchronized 只锁定当前链表或红黑二叉树的首节点。</li>
<li><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值（64）时，将链表转换为红黑树）。</li>
<li><strong>并发度</strong>：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li>
</ul>
<h3 id="集合使用"><a href="#集合使用" class="headerlink" title="集合使用"></a>集合使用</h3><h4 id="集合转Map"><a href="#集合转Map" class="headerlink" title="集合转Map"></a>集合转Map</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line">     <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; bookList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;18163138123&quot;</span>));</span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;martin&quot;</span>,<span class="literal">null</span>));</span><br><span class="line"><span class="comment">// 空指针异常</span></span><br><span class="line">bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line"><span class="comment">//没有指定类型的话会报错</span></span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]); <span class="comment">//注意这里的new String[0]起的就是一个模板的作用，但这里传入的只能为包装类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>&#125;; <span class="comment">// 这里的数组最好为包装类型</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">int</span>[] array = (<span class="type">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="System-arraycopy-和-Arrays-copyOf-方法"><a href="#System-arraycopy-和-Arrays-copyOf-方法" class="headerlink" title="System.arraycopy() 和 Arrays.copyOf()方法"></a>System.arraycopy() 和 Arrays.copyOf()方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   复制数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> src 源数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> srcPos 源数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> destPos 目标数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 要复制的数组元素的数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,</span></span><br><span class="line"><span class="params">                                    Object dest, <span class="type">int</span> destPos,</span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> length)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraycopyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">		a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">		a[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">		System.arraycopy(a, <span class="number">2</span>, a, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">		a[<span class="number">2</span>]=<span class="number">99</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">99</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">   	<span class="comment">// 申请一个新的数组</span></span><br><span class="line">       <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];</span><br><span class="line"><span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span></span><br><span class="line">       System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                        Math.min(original.length, newLength));</span><br><span class="line">       <span class="keyword">return</span> copy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， HashMap 总是使用 2 的幂作为哈希表的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值(容量*填充因子) 当实际大小超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>loadFactor 加载因子</strong>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。<strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</li>
<li><strong>thresholdthreshold &#x3D; capacity * loadFactor</strong>，<strong>当 Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</li>
</ul>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>扩容：ConcurrentHashMap 的扩容只会扩容到原来的两倍。老数组里的数据移动到新的数组时，位置要么不变，要么变为 index+ oldSize，参数里的 node 会在扩容之后使用链表<strong>头插法</strong>插入到指定位置。</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h3 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"></a>什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h3><ul>
<li><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li>
<li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>
<li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li>
<li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统</li>
</ul>
<h3 id="什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h3><ul>
<li><strong>元组</strong>：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li>
<li><strong>码</strong>：码就是能唯一标识实体的属性，对应表中的列。</li>
<li><strong>候选码</strong>：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li>
<li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li>
<li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>
<li><strong>主属性</strong>：候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>
<li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>
</ul>
<h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><p>全称实体联系图。</p>
<ul>
<li><strong>实体</strong>：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li>
<li><strong>属性</strong>：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用椭圆形表示。</li>
<li><strong>联系</strong>：即实体与实体之间的关系，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1685542336156-d45488ab-3518-453e-a582-fc0737a3ac62.png" alt="学生与课程之间的E-R图"></p>
<h3 id="表设计的原则（三大范式）"><a href="#表设计的原则（三大范式）" class="headerlink" title="表设计的原则（三大范式）"></a>表设计的原则（三大范式）</h3><ul>
<li>1NF(第一范式)：属性不可再分。</li>
<li>2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>
<li>3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖</li>
</ul>
<h3 id="不推荐使用外键和级联"><a href="#不推荐使用外键和级联" class="headerlink" title="不推荐使用外键和级联"></a>不推荐使用外键和级联</h3><blockquote>
<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>
</blockquote>
<blockquote>
<p>说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度；</p>
</blockquote>
<h3 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h3><p> 我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p>
<blockquote>
<p>在阿里巴巴Java开发手册中要求禁止使用存储过程；<br>存储过程难以调试和扩展，更没有移植性；</p>
</blockquote>
<h3 id="drop、delete-与-truncate-区别？"><a href="#drop、delete-与-truncate-区别？" class="headerlink" title="drop、delete 与 truncate 区别？"></a>drop、delete 与 truncate 区别？</h3><h4 id="用法不同"><a href="#用法不同" class="headerlink" title="# 用法不同"></a><a href="#%E7%94%A8%E6%B3%95%E4%B8%8D%E5%90%8C">#</a> 用法不同</h4><ul>
<li>drop(丢弃数据): drop table 表名 ，直接将表都删除掉，在删除表的时候使用。</li>
<li>truncate (清空数据) : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>
<li>delete（删除数据） : delete from 表名 where 列名&#x3D;值，删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似。</li>
</ul>
<p>truncate 和不带 where子句的 delete、以及 drop 都会删除表内的数据，但是 <strong>truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行drop 之后对应的表不复存在。</strong></p>
<h4 id="属于不同的数据库语言"><a href="#属于不同的数据库语言" class="headerlink" title="# 属于不同的数据库语言"></a><a href="#%E5%B1%9E%E4%BA%8E%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80">#</a> 属于不同的数据库语言</h4><p>truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。</p>
<blockquote>
<p>trigger：触发器<br>作用：实现由主键和外键所不能保证的复杂的参照完整性和数据的一致性。</p>
</blockquote>
<h3 id="触发器（之后详细看）"><a href="#触发器（之后详细看）" class="headerlink" title="触发器（之后详细看）"></a>触发器（之后详细看）</h3><p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。<br><strong>MYSQL不允许在触发器中调用存储过程。</strong></p>
<blockquote>
<p>注意：在 MySQL 中，分号 ; 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。<br>这时就会用到 DELIMITER 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：DELIMITER new_delemiter。new_delemiter 可以设为 1 个或多个长度的符号，默认的是分号 ;，我们可以把它修改为其他符号，如 DELIMITER $ 。在这之后的语句，以分号结束，解释器不会有什么反应，</p>
</blockquote>
<p><strong>NEW 和 OLD</strong>：</p>
<ul>
<li>MySQL 中定义了 NEW 和 OLD 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li>
<li>在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；</li>
<li>在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；</li>
<li>在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；</li>
<li>使用方法：NEW.columnName （columnName 为相应数据表某一列名）</li>
</ul>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">trigger_time</span><br><span class="line">trigger_event</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  trigger_statements</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>trigger_name：触发器名</li>
<li>trigger_time : 触发器的触发时机。取值为 BEFORE 或 AFTER。</li>
<li>trigger_event : 触发器的监听事件。取值为 INSERT、UPDATE 或 DELETE。</li>
<li>table_name : 触发器的监听目标。指定在哪张表上建立触发器。</li>
<li>FOR EACH ROW: 行级监视，Mysql 固定写法，其他 DBMS 不同。</li>
<li>trigger_statements: 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 ; 来结尾。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> `trigger_insert_user`</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `user_history`(user_id, operate_type, operate_time)</span><br><span class="line">    <span class="keyword">VALUES</span> (NEW.id, <span class="string">&#x27;add a user&#x27;</span>,  now());</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据库设计通常分为那几步？"><a href="#数据库设计通常分为那几步？" class="headerlink" title="数据库设计通常分为那几步？"></a>数据库设计通常分为那几步？</h3><ol>
<li>需求分析： 分析用户的需求，包括数据，功能和性能需求。</li>
<li>概念结构设计： 主要采用E-R模型进行设计，包括画E-R图。</li>
<li>逻辑结构设计：通过将E-R图转换成表，实现E-R模型到关系模型的转换。</li>
<li>物理结构设计：主要是为所设计的数据库选择合适的存储结构和存取路径。</li>
<li>数据库实施：包括编程、测试和运行。</li>
<li>数据库的运行和维护：系统的运行与数据库的日常维护。</li>
</ol>
<h3 id="NoSQL基础知识"><a href="#NoSQL基础知识" class="headerlink" title="NoSQL基础知识"></a>NoSQL基础知识</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>非关系型数据库，主要针对的是键值、文档以及图形类型数据存储。</p>
<h4 id="SQL与NoSQL的区别"><a href="#SQL与NoSQL的区别" class="headerlink" title="SQL与NoSQL的区别"></a>SQL与NoSQL的区别</h4><table>
<thead>
<tr>
<th></th>
<th>SQL数据库</th>
<th>NoSQL数据库</th>
</tr>
</thead>
<tbody><tr>
<td>数据存储类型</td>
<td>结构化数据，具有固定的行和列的表格</td>
<td>非结构化数据。文档：JSON文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td>
</tr>
<tr>
<td>ACID属性</td>
<td>提供原子性、一致性、隔离性和持久性</td>
<td>通常不支持ACID事务，为了支持可扩展性、高性能进行了权衡，少部分支持比如MongoDB。但与MySQL的事务支持还是有一定的区别的。</td>
</tr>
<tr>
<td>性能</td>
<td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构</td>
<td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序有关。</td>
</tr>
<tr>
<td>扩展</td>
<td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td>
<td>横向（增加服务器的方式横向扩展，通常是基于分片机制）</td>
</tr>
<tr>
<td>查询语言</td>
<td>结构化查询语言 (SQL)</td>
<td>数据访问语法可能因数据库而异</td>
</tr>
</tbody></table>
<h4 id="NoSQL的优势"><a href="#NoSQL的优势" class="headerlink" title="NoSQL的优势"></a>NoSQL的优势</h4><ul>
<li><strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。</li>
<li><strong>可扩展性：</strong> NoSQL 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li>
<li><strong>高性能：</strong> NoSQL 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li>
<li><strong>强大的功能：</strong> NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建</li>
</ul>
<h3 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h3><p>术语：模式（schema）关于数据库和表的布局及特征的信息。模式定义了数据在表中如何存储，包括存储什么样的数据，数据如何分解，个部分信息如何命名等信息。数据库和表都有模式。</p>
<p><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## 注释<span class="number">1</span></span><br><span class="line"><span class="comment">-- 注释2</span></span><br><span class="line"><span class="comment">/*注释3*/</span></span><br></pre></td></tr></table></figure>

<h4 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h4><ul>
<li>数据库定义语言（DDL）</li>
</ul>
<p>负责数据库结构定义与数据库对象定义的语言。核心指令为CEATE、ALTER、DROP</p>
<ul>
<li><p>数据操纵语言 （DML）</p>
<p>   用于对数据库的操作，对数据库其中的对象和数据运行访问工作的编程语句。核心指令为：INSERT、UPDATE、DELETE、SELECT等</p>
</li>
<li><p>事务控制语言 （TCL）</p>
</li>
</ul>
<p>Transaction Controller Language ，用于管理数据库中的事务。核心指令为：COMMIT、ROLLBACK</p>
<ul>
<li>数据控制语言 （DCL)</li>
</ul>
<p>Data Controller Language是一种对数据访问权进行控制的指令，他可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。核心指令为：GRANT、REVPKE。<br>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：CONNECT、SELECT、INSERT、UPDATE、DELETE、EXECUTE、USAGE、REFERENCES。</p>
<h4 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 语句用于从数据库中查询数据。</span><br><span class="line"><span class="keyword">DISTINCT</span> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</span><br><span class="line">LIMIT 限制返回的行数。可以有两个参数，第一个参数为起始行，从 <span class="number">0</span> 开始；第二个参数为返回的总行数。</span><br><span class="line"><span class="keyword">ASC</span> ：升序（默认）</span><br><span class="line"><span class="keyword">DESC</span> ：降序</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id <span class="keyword">FROM</span> products;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> MYTABLE limit <span class="number">3</span>, <span class="number">5</span>; <span class="operator">/</span><span class="operator">/</span> 编号从<span class="number">0</span>开始</span><br></pre></td></tr></table></figure>

<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><blockquote>
<p>子查询是嵌套在较大查询中的 SQL 查询。子查询也称为<strong>内部查询</strong>或<strong>内部选择</strong>，而包含子查询的语句也称为<strong>外部查询</strong>或<strong>外部选择</strong>。</p>
</blockquote>
<p><strong>子查询必须用圆括号（）括起来</strong><br>内部查询首先在其父查询之前执行，以可以将内部查询的结果传递给外部查询。<br>可以使用比较运算符，如 &gt;，&lt;，或 &#x3D;。比较运算符也可以是多行运算符，如 IN，ANY 或 ALL。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">where</span> cust_id <span class="keyword">In</span> </span><br><span class="line">(<span class="keyword">SELECT</span> cust_id <span class="keyword">from</span> orders </span><br><span class="line"> <span class="keyword">where</span> order_price <span class="operator">&gt;</span> <span class="keyword">All</span>(<span class="keyword">SELECT</span> orders_price <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> orders.id<span class="operator">=</span><span class="string">&#x27;12313&#x27;</span>));</span><br></pre></td></tr></table></figure>
<h4 id="连接和组合"><a href="#连接和组合" class="headerlink" title="连接和组合"></a>连接和组合</h4><h5 id="连接-（JOIN）"><a href="#连接-（JOIN）" class="headerlink" title="连接 （JOIN）"></a>连接 （JOIN）</h5><ul>
<li>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/webp/35372544/1685602639840-4ad03df8-1513-46ff-b560-d80b29bdd9af.webp#averageHue=%23e4c2c2&clientId=ua5b6bf02-486a-4&from=paste&id=ub962128a&originHeight=472&originWidth=600&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=u7396cb9a-5790-45d1-90f3-4c91fa097d9&title="></p>
<ul>
<li><strong>连接</strong>包括<ul>
<li>left join : 左连接，返回左表中所有的记录以及右表中连接字段相等的记录。</li>
<li>right join : 右连接，返回右表中所有的记录以及左表中连接字段相等的记录。</li>
<li>inner join : 内连接，又叫等值连接，只返回两个表中连接字段相等的行。</li>
<li>full join : 外连接，返回两个表中的行：left join + right join。</li>
<li>cross join : 结果是笛卡尔积，就是第一个表的行数乘以第二个表的行数。</li>
<li>GROUP BY:全外连接， 子句必须放在 WHERE 子句中的条件之后，必须放在 ORDER BY 子句之前<blockquote>
<p> select 语句中，如果没有 GROUP BY 语句，那么 cust_name、order_num 会返回若干个值，而 sum(quantity _ item_price) 只返回一个值，通过 group bycust_name 可以让 cust_name 和 sum(quantity _ item_price) 一一对应起来，或者说<strong>聚类</strong>，所以同样的，也要对 order_num 进行聚类。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>一句话，select 中的字段要么都聚类，要么都不聚类</strong><br>使用两个 <strong>INNER JOIN</strong> 子句来查询三个表中的数据：<br><strong>INNER JOIN 关键字在表中存在至少一个匹配时返回行。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="comment">--在下面吗三张表中需要查询的数据</span></span><br><span class="line">	product_name,</span><br><span class="line">	category_name,</span><br><span class="line">	brand_name, </span><br><span class="line">	list_price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	数据表(<span class="number">1</span>) p    <span class="comment">-- p是数据表的引用变量，可以通过p.出数据表格(1)中的列名 </span></span><br><span class="line"><span class="comment">--使用INNER JOIN通过数据表(1)category_id值查询出对应在数据表(2)的关联数据</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 数据表(<span class="number">2</span>) c <span class="keyword">ON</span> c数据表(<span class="number">2</span>).category_id <span class="operator">=</span> p数据表(<span class="number">1</span>).category_id </span><br><span class="line"><span class="comment">--使用INNER JOIN通过数据表(1)中brand_id值查询出对应在数据表(3)的关联数据</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 数据表(<span class="number">3</span>) b <span class="keyword">ON</span> b数据表(<span class="number">3</span>).brand_id <span class="operator">=</span> p数据表(<span class="number">1</span>).brand_id </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 	<span class="comment">--查询结果升序排序</span></span><br><span class="line">	product_name <span class="keyword">ASC</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在使用 left jion 时，on 和 where 条件的区别如下：</p>
<ul>
<li>1、 on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。</li>
<li>2、where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</li>
</ul>
<h5 id="组合-（UNION"><a href="#组合-（UNION" class="headerlink" title="组合 （UNION)"></a>组合 （UNION)</h5><p>UNION 将两个或多个查询的结果组合起来，并生成一个结果集，相当于将两个结构一样的表进行上下的拼接。</p>
<ul>
<li>所有查询的列数和列顺序必须相同</li>
<li>每个查询中设计表的列的数据类型必须相同或者兼容。</li>
<li>通常返回的列名取自第一个查询</li>
<li>默认会取出相同的行，如需保留，使用UNION ALL即可</li>
<li>只能包含一个ORDER BY字句放于语句的最后面</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LEFT(expression，length)、RIGHT(expression，length)</td>
<td>左边或者右边的字符</td>
</tr>
<tr>
<td>LOWER()、UPPER()</td>
<td>转换为小写或者大写</td>
</tr>
<tr>
<td>LTRIM()、RTIM()</td>
<td>去除左边或者右边的空格</td>
</tr>
<tr>
<td>LENGTH()</td>
<td>长度</td>
</tr>
<tr>
<td>SOUNDEX()</td>
<td>转换为语音值</td>
</tr>
</tbody></table>
<p>列子：从表数据中看到一个cust_contact为Y Sam的顾客，但是如果这是错误的输入，此联系名实际上应该是 Y San, 该怎么办呢？，显然按照正确的联系名搜索不会返回数据。现在soundex()函数就该大现身手了，使用soundex()函数进行搜索，它匹配所有发音类似于 Y San的联系名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span>  soundex(cust_contact) <span class="operator">=</span> soundex(<span class="string">&#x27;Y San&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>AddDate()</td>
<td>增加一个日期（天、周等）</td>
<td>SELECT ADDDATE(“2017-06-15”, INTERVAL 10 DAY);</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间（时、分等）</td>
<td>SELECT ADDTIME(“10:54:21”, “00:10:00”)  as Updated_time ;在已有时间上增加10分钟</td>
</tr>
<tr>
<td>CurDate()</td>
<td>返回当前日期</td>
<td>SELECT CurDate();</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前时间</td>
<td>SELECT CurTime();</td>
</tr>
<tr>
<td>Date()</td>
<td>返回日期时间的日期部分</td>
<td></td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
<td>ELECT DATEDIFF(day,’2008-12-29’,’2008-12-30’) AS DiffDate;两日期之间的天数</td>
</tr>
<tr>
<td>Date_Add()</td>
<td>高度灵活的日期运算函数</td>
<td>和AddDate()基本一致</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期或时间串</td>
<td></td>
</tr>
<tr>
<td>Day()</td>
<td>返回一个日期的天数部分</td>
<td></td>
</tr>
<tr>
<td>DayOfWeek()</td>
<td>对于一个日期，返回对应的星期几</td>
<td></td>
</tr>
<tr>
<td>Hour()</td>
<td>返回一个时间的小时部分</td>
<td></td>
</tr>
<tr>
<td>Minute()</td>
<td>返回一个时间的分钟部分</td>
<td></td>
</tr>
<tr>
<td>Month()</td>
<td>返回一个日期的月份部分</td>
<td></td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前日期和时间</td>
<td></td>
</tr>
<tr>
<td>Second()</td>
<td>返回一个时间的秒部分</td>
<td></td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分</td>
<td></td>
</tr>
<tr>
<td>Year()</td>
<td>返回一个日期的年份部分</td>
<td></td>
</tr>
</tbody></table>
<h4 id="having"><a href="#having" class="headerlink" title="having"></a>having</h4><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。<br>和 WHERE 子句一样，HAVING 子句后面也跟筛选条件，只有满足条件的数据才会被返回。您可以在 condition 条件中使用 &gt;、&lt;、&#x3D; 等比较运算符，或者使用 AND、OR 等逻辑运算符来指定多个条件，或者使用 LIKE、NOT LIKE 等进行模糊匹配。<br>HAVING 子句可以让我们筛选分组后的各组数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ip, <span class="built_in">COUNT</span>( username ) <span class="keyword">AS</span> total <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> ip <span class="keyword">HAVING</span> total <span class="operator">&gt;=</span><span class="number">2</span>;</span><br><span class="line">统计同一个 IP 地址上的用户注册数，筛选出注册数大于 <span class="number">2</span> 的结果集：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="修改数据库表"><a href="#修改数据库表" class="headerlink" title="修改数据库表"></a>修改数据库表</h3><h5 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> modify CLOUMN AGE TINYINT;</span><br></pre></td></tr></table></figure>
<h5 id="添加主键"><a href="#添加主键" class="headerlink" title="添加主键"></a>添加主键</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ADD</span> <span class="keyword">primary</span> key(id);</span><br></pre></td></tr></table></figure>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><blockquote>
<ul>
<li>定义<ul>
<li>视图是基于 SQL 语句的结果集的可视化的表。</li>
<li>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li>
</ul>
</li>
<li>作用<ul>
<li>简化复杂的 SQL 操作，比如复杂的联结；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> top_10_user_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> id, username</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><blockquote>
<ul>
<li>作用<ul>
<li>通过索引可以更加快速高效地查询数据。</li>
<li>用户无法看到索引，它们只能被用来加速查询。</li>
</ul>
</li>
<li>注意<ul>
<li>更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。</li>
</ul>
</li>
<li>唯一索引<ul>
<li>唯一索引表明此索引的每一个索引值只对应唯一的数据记录。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX user_index <span class="keyword">ON</span> <span class="keyword">user</span> (id);</span><br></pre></td></tr></table></figure>
<h4 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX user_index <span class="keyword">ON</span> <span class="keyword">user</span> (id);</span><br></pre></td></tr></table></figure>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">drop</span>  INDEX user_index</span><br></pre></td></tr></table></figure>

<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><blockquote>
<p>SQL约束用于规定表中的数据规则</p>
</blockquote>
<ul>
<li>如果存在违反约束的数据行为，行为会被约束终止。</li>
<li>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</li>
<li>约束类型<ul>
<li>NOT NULL - 指示某列不能存储 NULL 值。</li>
<li>UNIQUE - 保证某列的每行必须有唯一的值。</li>
<li>PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li>
<li>FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。</li>
<li>CHECK - 保证列中的值符合指定的条件。</li>
<li>DEFAULT - 规定没有给列赋值时的默认值。</li>
</ul>
</li>
</ul>
<h5 id="check"><a href="#check" class="headerlink" title="check"></a>check</h5><p>定义多个列的CHECK约束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line"></span><br><span class="line">ID <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">name <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line"></span><br><span class="line">age <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line"></span><br><span class="line">country <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line"></span><br><span class="line"><span class="keyword">CONSTRAINT</span> chk_Person <span class="keyword">CHECK</span>(ID<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">AND</span> country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span>)</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>当表已经创建，定义多个列的CHECK约束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> chk_Person</span><br><span class="line"></span><br><span class="line"><span class="keyword">CHECK</span>(ID<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">AND</span> country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h3><blockquote>
<ul>
<li>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</li>
<li><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</li>
<li>通过 set autocommit&#x3D;0 可以取消自动提交，直到 set autocommit&#x3D;1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。</li>
<li>指令<ul>
<li>START TRANSACTION - 指令用于标记事务的起始点。</li>
<li>SAVEPOINT - 指令用于创建保留点。</li>
<li>ROLLBACK TO - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 START TRANSACTION 语句处。</li>
<li>COMMIT - 提交事务。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 A</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建保留点 updateA</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到保留点 updateA</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> updateA; <span class="operator">/</span><span class="operator">/</span> 执行到这里之后就会进行回滚</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，只有操作 A 生效</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><blockquote>
<ul>
<li>GRANT 和 REVOKE 可在几个层次上控制访问权限：<ul>
<li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li>
<li>整个数据库，使用 ON database.*；</li>
<li>特定的表，使用 ON database.table；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
</li>
<li>新创建的账户没有任何权限。</li>
<li>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</li>
<li>MySQL 的账户信息保存在 mysql 这个数据库中。</li>
</ul>
</blockquote>
<p>创建用户</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> ‘hzm’ identified <span class="keyword">by</span> ‘<span class="number">123456</span>’ # hzm：用户账号，<span class="number">123456</span>：密码</span><br></pre></td></tr></table></figure>
<p>修改账户名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;newuser&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;myuser&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES; <span class="comment">--刷新</span></span><br></pre></td></tr></table></figure>
<h4 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> myuser；</span><br></pre></td></tr></table></figure>
<p>授予权限</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> myuser;</span><br><span class="line"></span><br><span class="line">语法格式</span><br><span class="line"><span class="keyword">GRANT</span></span><br><span class="line"><span class="operator">&lt;</span>权限类型<span class="operator">&gt;</span> [ ( <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> ) ] [ , <span class="operator">&lt;</span>权限类型<span class="operator">&gt;</span> [ ( <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> ) ] ]</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象<span class="operator">&gt;</span> <span class="operator">&lt;</span>权限级别<span class="operator">&gt;</span> <span class="keyword">TO</span> <span class="operator">&lt;</span>用户<span class="operator">&gt;</span></span><br><span class="line">其中<span class="operator">&lt;</span>用户<span class="operator">&gt;</span>的格式：</span><br><span class="line"><span class="operator">&lt;</span>用户名<span class="operator">&gt;</span> [ IDENTIFIED ] <span class="keyword">BY</span> [ PASSWORD ] <span class="operator">&lt;</span>口令<span class="operator">&gt;</span></span><br><span class="line">[ <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION]</span><br><span class="line"><span class="operator">|</span> MAX_QUERIES_PER_HOUR <span class="operator">&lt;</span>次数<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> MAX_UPDATES_PER_HOUR <span class="operator">&lt;</span>次数<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> MAX_CONNECTIONS_PER_HOUR <span class="operator">&lt;</span>次数<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">|</span> MAX_USER_CONNECTIONS <span class="operator">&lt;</span>次数<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>对应地，在 GRANT 语句中可用于指定权限级别的值有以下几类格式：</strong></p>
<ul>
<li>*：表示当前数据库中的所有表。</li>
<li>*.*：表示所有数据库中的所有表。</li>
<li>db_name.*：表示某个数据库中的所有表，db_name 指定数据库名。</li>
<li>db_name.tbl_name：表示某个数据库中的某个表或视图，db_name 指定数据库名，tbl_name 指定表名或视图名。</li>
<li>tbl_name：表示某个表或视图，tbl_name 指定表名或视图名。</li>
<li>db_name.routine_name：表示某个数据库中的某个存储过程或函数，routine_name 指定存储过程名或函数名。</li>
<li>TO 子句：用来设定用户口令，以及指定被赋予权限的用户 user。若在 TO 子句中给系统中存在的用户指定口令，则新密码会将原密码覆盖；如果权限被授予给一个不存在的用户，MySQL 会自动执行一条 CREATE USER 语句来创建这个用户，但同时必须为该用户指定口令</li>
</ul>
<h4 id="删除权限"><a href="#删除权限" class="headerlink" title="删除权限"></a>删除权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure>

<h3 id="储存过程"><a href="#储存过程" class="headerlink" title="储存过程"></a>储存过程</h3><blockquote>
<ul>
<li>存储过程可以看成是对一系列 SQL 操作的批处理；</li>
<li>使用存储过程的好处<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。</li>
</ul>
</li>
<li>创建存储过程<ul>
<li>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li>
<li>包含 in、out 和 inout 三种参数。</li>
<li>给变量赋值都需要用 select into 语句。</li>
<li>每次只能给一个变量赋值，不支持集合的操作。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> IF <span class="keyword">EXISTS</span> `proc_adder`;</span><br><span class="line">DELIMITER ;;</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`root`@`localhost` <span class="keyword">PROCEDURE</span> `proc_adder`(<span class="keyword">IN</span> a <span class="type">int</span>, <span class="keyword">IN</span> b <span class="type">int</span>, <span class="keyword">OUT</span> sum <span class="type">int</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> c <span class="type">int</span>;</span><br><span class="line">    if a <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="keyword">set</span> a <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">    if b <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="keyword">set</span> b <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> sum  <span class="operator">=</span> a <span class="operator">+</span> b;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">;;</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>存储在DBMS服务器上的数据查询，是被SELECT语句查询出来的结果集。</p>
<h3 id="MySQL面试题"><a href="#MySQL面试题" class="headerlink" title="MySQL面试题"></a>MySQL面试题</h3><h4 id="MySQL的优点"><a href="#MySQL的优点" class="headerlink" title="MySQL的优点"></a>MySQL的优点</h4><ul>
<li>成熟稳定，功能完善</li>
<li>开源免费</li>
<li>文档丰富，便于学习</li>
<li>开箱即用，操作简单</li>
<li>兼容性好</li>
<li>事务支持优秀</li>
<li>支持分库分表、读写分离、高可用</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686303414698-55b62c03-8bf7-4be0-975f-140fa1749f81.png" alt="image.png">&#96;&#96;</p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li>
<li><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>
</ul>
<h4 id="MySQL储存引擎"><a href="#MySQL储存引擎" class="headerlink" title="MySQL储存引擎"></a>MySQL储存引擎</h4><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。并且所有的引擎中只有InnoDB支持事务性储存引擎。<br>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong><br><strong>InnoDB与MySQL的区别</strong></p>
<ul>
<li>是否支持行级锁</li>
</ul>
<p>InnoDB支持行级锁，且默认为行级锁，MyISAM只支持表级锁</p>
<ul>
<li>是否支持事务</li>
</ul>
<p>只有InnoDB支持事务</p>
<ul>
<li>是否支持外键</li>
</ul>
<p>MyISAM不支持外键</p>
<ul>
<li><strong>.是否支持数据库异常崩溃后的安全恢复</strong></li>
</ul>
<p>MyISAM 不支持，而 InnoDB 支持。<br>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo log 。</p>
<ul>
<li>是否支持MVCC</li>
</ul>
<p>MyISAM 不支持，而 InnoDB 支持。<br>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p>
<ul>
<li><strong>索引实现不一样。</strong></li>
</ul>
<p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。<br>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p><strong>要么全部执行成功,要么全部不执行</strong> 。</p>
<ul>
<li><strong>原子性</strong>（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（Consistency）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong></p>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p>一个事物读取了另一个事物已经修改但还未提交的事务，单独读取之后另一个事物突然回滚导致本次读取的数据是错误的。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1685673866111-3eb48b1a-62a8-4517-bdc5-9251d17b4682.png" alt="脏读"></p>
<h5 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h5><p>一个事务读取数据之后，另一个数据也读取了本数据，但因为两次数据的修改提交的先后顺序导致先提交的修改没起作用。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1685673970417-e6572263-0378-4203-a88d-792e7a0a9c2f.png" alt="丢失修改"></p>
<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><p>一个事务A在读取数据之后，另一个事物B也读取了本数据并修改了本数据，当A事务再一次读取数据时发现本次读取的数据与上一次的不一致。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1685674161104-6cc42387-f7da-4b53-a00e-02d655eb3b8f.png" alt="不可重复读"></p>
<h5 id="幻读（唯一的写数据失物）"><a href="#幻读（唯一的写数据失物）" class="headerlink" title="幻读（唯一的写数据失物）"></a>幻读（唯一的写数据失物）</h5><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1685674234794-b4ca67d1-1777-4188-ac67-bed3cd3e38b4.png" alt="幻读"></p>
<h4 id="并发事务的控制"><a href="#并发事务的控制" class="headerlink" title="并发事务的控制"></a>并发事务的控制</h4><p> MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p>
<blockquote>
<p>MySQL中主要是通过读写锁来实现并发控制</p>
</blockquote>
<ul>
<li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>
<li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li>
</ul>
<p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><ul>
<li>**READ-UNCOMMITTED(读取未提交)**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>**READ-COMMITTED(读取已提交)**：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li>**REPEATABLE-READ(可重复读)**：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>**SERIALIZABLE(可串行化)**：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
</li>
</ul>
<p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。<br>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读</p>
<h4 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h4><p><strong>表级锁和行级锁对比</strong>：</p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li>
</ul>
<h4 id="行级锁的使用有什么注意事项？"><a href="#行级锁的使用有什么注意事项？" class="headerlink" title="行级锁的使用有什么注意事项？"></a>行级锁的使用有什么注意事项？</h4><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 UPDATE、DELETE 语句时，如果 WHERE条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！<br>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p>
<h4 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h4><ul>
<li><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。</li>
<li><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p><strong>什么是Next-Key Lock？（大厂问的比较多）</strong><br><strong>记录锁与索引记录之前的间隙上的间隙锁的组合。</strong><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1685687086930-1f597c28-12b2-4e40-bee2-31bbf1be849a.png" alt="image.png"></p>
<h4 id="共享锁和排它锁"><a href="#共享锁和排它锁" class="headerlink" title="共享锁和排它锁"></a>共享锁和排它锁</h4><ul>
<li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>
<li><strong>排他锁（X 锁）</strong>：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li>
</ul>
<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。<br>由于 MVCC 的存在，对于一般的 SELECT 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 共享锁</span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"># 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>用于快速判断是否可以对某个表示用表锁。意向锁之间是互相兼容的。</p>
<p>| </p>
<p> | IS 锁 | IX 锁 |<br>| — | — | — |<br>| S 锁 | 兼容 | 互斥 |<br>| X 锁 | 互斥 | 互斥 |</p>
<h4 id="当前读和快照读有什么区别？"><a href="#当前读和快照读有什么区别？" class="headerlink" title="当前读和快照读有什么区别？"></a>当前读和快照读有什么区别？</h4><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 SELECT 语句，但不包括下面这两类 SELECT 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE</span><br></pre></td></tr></table></figure>
<p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。（相当于读取加上X锁之前的数据）<br>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p>
<ul>
<li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li>
<li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li>
</ul>
<p><strong>当前读 （一致性锁定读）就是给行记录加 X 锁或 S 锁。</strong><br>当前读的一些常见 SQL 语句类型如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 对读的记录加一个X锁</span><br><span class="line">SELECT...FOR <span class="keyword">UPDATE</span></span><br><span class="line"># 对读的记录加一个S锁</span><br><span class="line">SELECT...LOCK <span class="keyword">IN</span> SHARE MODE</span><br><span class="line"># 对修改的记录加一个X锁</span><br><span class="line">INSERT...</span><br><span class="line">UPDATE...</span><br><span class="line">DELETE...</span><br></pre></td></tr></table></figure>
<h4 id="MySQL-如何存储-IP-地址？"><a href="#MySQL-如何存储-IP-地址？" class="headerlink" title="MySQL 如何存储 IP 地址？"></a>MySQL 如何存储 IP 地址？</h4><ul>
<li>INET_ATON()：把 ip 转为无符号整型 (4-8 位)</li>
<li>INET_NTOA() :把整型的 ip 转为地址</li>
</ul>
<p>插入数据前，先用 INET_ATON() 把 ip 地址转为整型，显示数据时，使用 INET_NTOA() 把整型的 ip 地址转为地址显示即可</p>
<h4 id="如何分析-SQL-的性能？"><a href="#如何分析-SQL-的性能？" class="headerlink" title="如何分析 SQL 的性能？"></a>如何分析 SQL 的性能？</h4><p>我们可以使用 EXPLAIN 命令来分析 SQL 的 <strong>执行计划</strong> 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。<br>EXPLAIN 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。<br>就是在语句的前面加上 EXPLAIN</p>
<h3 id="MySQL高性能优化规范建议总结"><a href="#MySQL高性能优化规范建议总结" class="headerlink" title="MySQL高性能优化规范建议总结"></a>MySQL高性能优化规范建议总结</h3><h4 id="尽量控制单表数据量的大小，建议控制在-500-万以内"><a href="#尽量控制单表数据量的大小，建议控制在-500-万以内" class="headerlink" title="尽量控制单表数据量的大小，建议控制在 500 万以内"></a>尽量控制单表数据量的大小，建议控制在 500 万以内</h4><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。<br>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
<h4 id="不要被数据库范式所束缚"><a href="#不要被数据库范式所束缚" class="headerlink" title="不要被数据库范式所束缚"></a>不要被数据库范式所束缚</h4><p>一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。</p>
<h4 id="MySQL默认值选型是空，还是NULL"><a href="#MySQL默认值选型是空，还是NULL" class="headerlink" title="MySQL默认值选型是空，还是NULL"></a>MySQL默认值选型是空，还是NULL</h4><p><strong>1. NULL 与空字符存储上的区别</strong><br>表中如果允许字段为 NULL，会为每行记录分配 NULL 标志位。NULL 除了在每行的行首存有 NULL 标志位，实际存储不占有任何空间。如果表中所有字段都是非 NULL，就不存在这个标示位了。<br><strong>2. NULL使用上的一些问题。</strong><br>数值类型，对一个允许为NULL的字段进行min、max、sum、加减、order by、group by、distinct 等操作的时候。字段值为非 NULL 值时，操作很明确。如果使用 NULL， 需要清楚的知道如下规则：</p>
<ul>
<li>数值类型：聚合函数会将其忽略，对NULL进行加减操作任会是NULL，order by升序时NULL会排在最前面，group by 、 distinct时，NULL值会被视为相同的值</li>
<li>字符类型：字段是字符时，你无法一目了然的区分这个值到底是 NULL ，还是字符串 ‘NULL’等</li>
</ul>
<p><strong>总结：</strong></p>
<p>NULL 本身是一个特殊值，MySQL 采用特殊的方法来处理 NULL 值。从理解肉眼判断，操作符运算等操作上，可能和我们预期的效果不一致。可能会给我们项目上的操作不符合预期。<br>你必须要使用 IS NULL &#x2F; IS NOT NULL 这种与普通 SQL 大相径庭的方式去处理 NULL。<br>尽管在存储空间上，在索引性能上可能并不比空值差，但是为了避免其身上特殊性，给项目带来不确定因素，<strong>因此建议默认值不要使用 NULL。</strong></p>
<h4 id="使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间"><a href="#使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间" class="headerlink" title="使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间"></a>使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h4><p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07<br>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高<br>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p>
<h4 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h4><ul>
<li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li>
<li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li>
<li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li>
<li>多表 join 的关联列</li>
</ul>
<h4 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="如何选择索引列的顺序"></a>如何选择索引列的顺序</h4><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>
<ul>
<li>区分度最高的放在联合索引的最左侧（区分度&#x3D;列中不同值的数量&#x2F;列的总行数）</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li>
<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>
</ul>
<h3 id="MySQL索引详解"><a href="#MySQL索引详解" class="headerlink" title="MySQL索引详解"></a>MySQL索引详解</h3><h4 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h4><p>介绍：索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<blockquote>
<p>简单理解为“排好序的可以快速查找数据的数据结构”。</p>
</blockquote>
<p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。</p>
<h5 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h5><p>表中的列建立索引后，数据库会自动建立主键索引。</p>
<h5 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h5><p>表中的列创建了唯一约束时，数据库会自动建立唯一索引。 在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span>  <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">unique</span> 索引名(字段)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index 索引名 <span class="keyword">on</span> 表名(字段)</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> index 索引名 <span class="keyword">on</span> 表名</span><br></pre></td></tr></table></figure>
<h5 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h5><p>即一个索引只包含单个列，一个表可以有多个单值索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span>  <span class="keyword">table</span> 表名 <span class="keyword">add</span> index 索引名(字段)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span>  index 索引名 <span class="keyword">on</span> 表名(字段)</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> index 索引名 <span class="keyword">on</span> 表名</span><br></pre></td></tr></table></figure>

<h5 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h5><p>一个索引包含多个列</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(字段<span class="number">1</span>，字段<span class="number">2</span>)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> index 索引名(字段<span class="number">1</span>，字段<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h5 id="随表创建索引"><a href="#随表创建索引" class="headerlink" title="随表创建索引"></a>随表创建索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> customer(</span><br><span class="line">	id <span class="type">int</span>(<span class="number">10</span>) auto_increment，</span><br><span class="line">  customer_no <span class="type">varchar</span>( <span class="number">20</span>),</span><br><span class="line">  customer_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  <span class="keyword">primary</span> key(id) , # 创建主键索引</span><br><span class="line">	<span class="keyword">unique</span> idx_customer_no(customer_no) , # 创建唯一索引</span><br><span class="line">  key idx_customer_name( customer_name ) , # 创建单值索引</span><br><span class="line">	key idex_customer_no_name(customer_no,customer_name) # 创建复合索引</span><br><span class="line">  )</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>对文本的前几个字符建立索引（具体是几个字符在建立索引时指定），这样建立起来的索引更小，所以查询更快。<br>那么为什么不对整个字段建立索引呢？一般来说使用前缀索引，可能都是因为整个字段的数据量太大，没有必要针对整个字段建立索引，前缀索引仅仅是选择一个字段的部分字符作为索引，这样一方面可以节约索引空间，另一方面则可以提高索引效率，当然很明显，这种方式也会降低索引的选择性</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>对于频繁的查询优先考虑的就是使用覆盖索引，覆盖索引就是包含了所有查询字段的索引。<br><strong>覆盖索引的好处：</strong></p>
<ul>
<li><strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>
<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li>
</ul>
<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。<br>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，MyISAM索引文件和数据文件是分离的，InnoDB表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p><strong>二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong><br>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<ul>
<li><strong>唯一索引(Unique Key)<strong>：唯一索引也是一种约束。</strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)<strong>：</strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li>**前缀索引(Prefix)**：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li>
<li>**全文索引(Full Text)**：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ul>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><p>聚簇索引与非聚簇索引<br>聚簇索引（聚集索引）：<br><strong>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</strong><br><strong>聚簇索引的优缺点</strong><br><strong>优点</strong>：</p>
<ul>
<li><strong>查询速度非常快</strong>：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li>
<li><strong>对排序查找和范围查找优化</strong>：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>依赖于有序的数据</strong>：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ul>
<h5 id="非聚簇索引介绍"><a href="#非聚簇索引介绍" class="headerlink" title="非聚簇索引介绍"></a>非聚簇索引介绍</h5><p><strong>非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</strong><br>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。<br><a href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><strong>#</strong></a>** 非聚簇索引的优缺点**<br><strong>优点</strong>：<br>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的<br><strong>缺点</strong>：</p>
<ul>
<li><strong>依赖于有序的数据</strong>：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li>
<li>**可能会二次查询(回表)**：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ul>
<p><strong>索引下推 ICP</strong><br>将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。<br>我们来具体看一下，在没有使用ICP的情况下，MySQL的查询：</p>
<ul>
<li>存储引擎读取索引记录；</li>
<li>根据索引中的主键值，定位并读取完整的行记录；</li>
<li>存储引擎把记录交给<strong>Server</strong>层去检测该记录是否满足<strong>WHERE</strong>条件。</li>
</ul>
<p>使用ICP的情况下，查询过程：</p>
<ul>
<li>存储引擎读取索引记录（不是完整的行记录）；</li>
<li>判断<strong>WHERE</strong>条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；</li>
<li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li>
<li>存储引擎把记录交给<strong>Server</strong>层，<strong>Server</strong>层检测该记录是否满足<strong>WHERE</strong>条件的其余部分。</li>
</ul>
<p><strong>索引下推使用条件</strong></p>
<ul>
<li>只能用于<strong>range</strong>、 <strong>ref</strong>、 <strong>eq_ref</strong>、<strong>ref_or_null</strong>访问方法；</li>
<li>只能用于<strong>InnoDB</strong>和 <strong>MyISAM</strong>存储引擎及其分区表；</li>
<li>对<strong>InnoDB</strong>存储引擎来说，索引下推只适用于二级索引（也叫辅助索引）;</li>
</ul>
<p>索引下推的目的是为了减少回表次数，也就是要减少IO操作。对于<strong>InnoDB</strong>的<strong>聚簇索引</strong>来说，数据和索引是在一起的，不存在回表这一说。</p>
<ul>
<li>引用了子查询的条件不能下推；</li>
<li>引用了存储函数的条件不能下推，因为存储引擎无法调用存储函数。</li>
</ul>
<h4 id="正确使用索引的一些建议"><a href="#正确使用索引的一些建议" class="headerlink" title="正确使用索引的一些建议"></a>正确使用索引的一些建议</h4><h5 id="选择合适的字段创建索引"><a href="#选择合适的字段创建索引" class="headerlink" title="# 选择合适的字段创建索引"></a><a href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">#</a> 选择合适的字段创建索引</h5><ul>
<li><strong>不为 NULL 的字段</strong>：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong>：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong>：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong>：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong>：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
<h5 id="被频繁更新的字段应该慎重建立索引"><a href="#被频繁更新的字段应该慎重建立索引" class="headerlink" title="# 被频繁更新的字段应该慎重建立索引"></a><a href="#%E8%A2%AB%E9%A2%91%E7%B9%81%E6%9B%B4%E6%96%B0%E7%9A%84%E5%AD%97%E6%AE%B5%E5%BA%94%E8%AF%A5%E6%85%8E%E9%87%8D%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95">#</a> 被频繁更新的字段应该慎重建立索引</h5><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<h5 id="限制每张表上的索引数量"><a href="#限制每张表上的索引数量" class="headerlink" title="# 限制每张表上的索引数量"></a><a href="#%E9%99%90%E5%88%B6%E6%AF%8F%E5%BC%A0%E8%A1%A8%E4%B8%8A%E7%9A%84%E7%B4%A2%E5%BC%95%E6%95%B0%E9%87%8F">#</a> 限制每张表上的索引数量</h5><p>索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。<br>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。<br>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>
<h5 id="尽可能的考虑建立联合索引而不是单列索引"><a href="#尽可能的考虑建立联合索引而不是单列索引" class="headerlink" title="# 尽可能的考虑建立联合索引而不是单列索引"></a><a href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E8%80%83%E8%99%91%E5%BB%BA%E7%AB%8B%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95">#</a> 尽可能的考虑建立联合索引而不是单列索引</h5><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<h5 id="注意避免冗余索引"><a href="#注意避免冗余索引" class="headerlink" title="# 注意避免冗余索引"></a><a href="#%E6%B3%A8%E6%84%8F%E9%81%BF%E5%85%8D%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95">#</a> 注意避免冗余索引</h5><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<h5 id="字符串类型的字段使用前缀索引代替普通索引"><a href="#字符串类型的字段使用前缀索引代替普通索引" class="headerlink" title="# 字符串类型的字段使用前缀索引代替普通索引"></a><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E4%BB%A3%E6%9B%BF%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95">#</a> 字符串类型的字段使用前缀索引代替普通索引</h5><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h5 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="# 避免索引失效"></a><a href="#%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88">#</a> 避免索引失效</h5><p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p>
<ul>
<li><del>使用 SELECT * 进行查询;</del>SELECT * 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖;</li>
<li>创建了组合索引，但查询条件未遵守最左匹配原则;</li>
<li>在索引列上进行计算、函数、类型转换等操作;</li>
<li>以 % 开头的 LIKE 查询比如 like ‘%abc’;</li>
<li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li>
<li>发生<a href="/database/mysql/index-invalidation-caused-by-implicit-conversion.html">隐式转换</a>;</li>
<li>……</li>
</ul>
<h5 id="删除长期未使用的索引"><a href="#删除长期未使用的索引" class="headerlink" title="# 删除长期未使用的索引"></a><a href="#%E5%88%A0%E9%99%A4%E9%95%BF%E6%9C%9F%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95">#</a> 删除长期未使用的索引</h5><p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。<br>MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用。</p>
<h4 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h4><p><strong>type</strong></p>
<ol>
<li>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</li>
<li>const：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快，如将主键置于where列表中，mysql就能将该查询转换为一个常量。</li>
<li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li>
<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该数据查找和扫描的混合体。</li>
<li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</li>
<li>index：full index scan，index与all区别为index类型只遍历索引树。这通常比all快，因为索引文件通常比数据文件小，也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的。</li>
<li>all：full table scan，将遍历全表以找到匹配的行。</li>
<li>从最好到最差依次是system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all。一般来说，最好保证查询能达到range级别，最好能达到ref。</li>
</ol>
<p>possible_keys:显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上如果存在索引，则该索引将会被列出来，但不一定会被查询实际使用上。<br>key:查询中实际使用的索引，如果为null，则没有使用索引<br>key_len:值越大说明对索引的使用越充分。<br>ref：显示索引的哪一列被使用了，哪些列或常量被用于查找索引列上的值。<br>rows:rows列显示MySQL认为它执行查询时必须检查的行数，一般越少越好。<br>extra：一些常见的重要的额外信息：</p>
<ol>
<li>using filesort：MySQL无法利用索引完成的<strong>排序</strong>操作（没有使用索引）称为“文件排序”（排序时没有使用索引，需要优化）</li>
<li>Using temporary：MySQL在对查询结果分组时使用临时表，常见于排序order by和分组查询group by。（分组时没有使用索引，需要优化）</li>
<li>Using index：表示索引被用来执行行索引键值的查找，避免访问了表的数据行，效率不错。</li>
<li>Using where：表示使用了where过滤。</li>
</ol>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">add</span> index idx_sname_age_score(sname,age,score);</span><br></pre></td></tr></table></figure>
<p><strong>索引失效</strong></p>
<ul>
<li>最佳左前缀法则：如果索引了多列，要遵循最左前缀法则，指的是查询从索引的最左前列开始并且不跳过索引中的列。否则会导致索引失效。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1685708640443-28c20f0f-6023-4958-a30b-24c80ef7c61c.png" alt="image.png"></p>
<ul>
<li><p>不在索引列上做任何计算、函数操作，会导致索引失效而转向全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> <span class="keyword">left</span>(sname,<span class="number">2</span>) <span class="operator">=</span>&quot;小明&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>存储引擎不能使用索引中范围条件右边的列（只有定义索引时的顺序有关）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> sname<span class="operator">=</span>&quot;小明&quot; <span class="keyword">and</span> age <span class="operator">&gt;</span> <span class="number">22</span> <span class="keyword">and</span> score <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">#这里的score因为在范围条件age <span class="operator">&gt;</span> <span class="number">22</span> 右边所以索引没有起到作用</span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL在使用不等于时无法使用索引会导致全表扫描。</p>
</li>
<li><p>is null 可以使用索引，但是is not null无法使用索引。</p>
</li>
<li><p>like以通配符开头会使索引失效导致全表扫描。</p>
</li>
<li><p>字符串不加单引号索引会失效。</p>
</li>
<li><p>使用or连接时索引失效</p>
</li>
</ul>
<p> 最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 <strong>&gt;<strong>、</strong>&lt;**）才会停止匹配。对于 **&gt;&#x3D;<strong>、</strong>&lt;&#x3D;<strong>、</strong>BETWEEN</strong>、<strong>like</strong> 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p>
<p><strong>建议：</strong></p>
<ul>
<li>and会自动调整顺序为最左前列</li>
<li>对于单值索引，尽量选择针对当前查询字段过滤性更好的索引</li>
<li>对于组合索引，当前where查询中过滤性更好的字段在索引字段顺序中位置越靠前越好</li>
<li>对于组合索引，尽量选择能够包含在当前查询中where子句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li>
</ul>
<h5 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h5><p>内连接时，MySQL会自动把小结果集的选为驱动表，所以大表的字段最好加上索引，左外连接时，左表会全表扫描，所以右边大表字段最好加上索引，右外连接同理，我们最好保证<strong>被驱动表</strong>上的字段建立了索引。<br>order by语句里有的字段升序有的字段 降序，那是不能用索引的 另外，要是你order by语句里有的字段不在联合索引里，或者是你对order by语句里的字段用了复杂的 函数，这些也不能使用索引去进行排序了。</p>
<h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>概念：mysql的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超越阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中，可以由它来查看哪些SQL超出了我们最大忍耐时间值。</p>
<ol>
<li>慢查询日志使用</li>
<li>默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数。</li>
<li>查看是否开启：show variables like ‘%slow_query_log%’;</li>
<li>开启日志：set global slow_query_log &#x3D; 1;</li>
<li>设置时间：set global long_query_time&#x3D;1;</li>
<li>查看时间：show vari ables like ‘long_query_time%’;</li>
<li>查看超时的SQL记录日志：MySQL的数据文件夹下：5.5&#x2F;Data&#x2F;设备名称-slow.log</li>
<li>注意：非调优场景下，一般不建议启动改参数，慢查询日志支持将日志记录写入文件，开启慢查询日志会或多或少带来一定的性能影响。</li>
</ol>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h3 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h3><p>MySQL日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中比较重要的是二进制日志binlog（归档日志）和事务日志redo log（重做日志）和undo log（回滚日志）。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686291709767-9f2a4dad-5c3e-46a7-b8ae-f0f2c5c4a683.png" alt="image.png"></p>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>重做日志是InnoDB存储引擎独有的，他让MySQL拥有了崩溃恢复能力。<br>一般会把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）中，接着刷盘到redo.file文件中。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686292048404-a2240706-3fd8-490d-92d3-11c75975aed3.png" alt="image.png"></p>
<p>理想情况是事物一旦提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。<br>redo记录 &#x3D; 空间表号 + 数据页号  + 偏移量 + 修改数据长度 + 具体修改的数据</p>
<h4 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h4><p>InnoDB 存储引擎为 redo log 的刷盘策略提供了 innodb_flush_log_at_trx_commit 参数，它支持三种策略：</p>
<ul>
<li><strong>0</strong>：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li>
<li><strong>1</strong>：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>
<li><strong>2</strong>：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>
</ul>
<p>innodb_flush_log_at_trx_commit 参数默认为 1 ，也就是说当事务提交时会调用 fsync 对 redo log 进行刷盘<br>另外，InnoDB 存储引擎有一个后台线程，每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686292330537-56bc1174-7e60-4bab-aa7b-dc409122b5af.png" alt="image.png"><br>除了后台线程每秒1次的轮询操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686294379664-430755db-8222-448e-be28-d3410f31210a.png" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686294391517-c76e47d8-1811-47ea-bbb4-2a505e528d7a.png" alt="image.png"></p>
<blockquote>
<p>数据库挂了和宕机都表示数据库无法正常工作，但是它们之间存在一些区别。<br>数据库挂了是指数据库系统在某个时间点无法响应任何请求或者响应时间过长，但是数据库还没有完全崩溃或停止。这种情况通常是由于数据库系统的资源不足或者某些进程出现了问题造成的。<br>而数据库宕机则是指数据库系统完全崩溃或停止工作，无法正常响应任何请求。这种情况通常是由于硬件故障、软件错误或者系统崩溃等原因造成的。<br>综上所述，数据库挂了是指数据库系统的某些部分出现了问题，而数据库宕机则是指整个数据库系统无法正常工作。</p>
</blockquote>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID &#x3D; 2 这一行的c字段加上1”，属于MySQL Server层。。<br>一般的数据备份，主备、主主、主从都离不开binlog，需要依靠binlog 来同步数据，保证数据一致性。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686295946610-25b61dca-aabe-44c3-a406-c03bc2628ea6.png" alt="image.png"><br>binlog会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>
<p><strong>写入机制</strong><br>binlog的写入时机也非常简单，事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。<br>因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。<br>我们可以通过binlog_cache_size参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。<br>binlog日志刷盘流程如下<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686296209138-ac94e057-40e4-4cc4-bc59-ae06e86e32dd.png" alt="image.png"></p>
<ul>
<li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>
<li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li>
</ul>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>redo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复能力。<br>binlog（归档日志）保证了MySQL集群架构的数据一致性。<br>虽然它们都属于持久化的保证，但是侧重点不同。<br>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。</p>
<p><strong>假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢？</strong><br> 由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。因此，之后用binlog日志恢复数据时，就会少这一次更新，恢复出来的这一行c值是0，而原库因为redo log日志恢复，这一行c值是1，最终数据不一致。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686296799028-c76fba0b-9aba-4e17-b106-744c9ccbbb4d.png" alt="image.png">为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。<br>原理很简单，将redo log的写入拆成了两个步骤prepare和commit，这就是<strong>两阶段提交</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686296846780-4f0d68d9-2657-4420-b423-4b439d6989e8.png" alt="image.png"><br>使用<strong>两阶段提交</strong>后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686296867918-43516d74-f0d3-4870-a309-e04582ee73e1.png" alt="image.png"></p>
<h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p> 我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。<br>MySQL数据库的<strong>数据备份、主备、主主、主从</strong>都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</p>
<h3 id="InnoDB存储引擎对MVCC的实现"><a href="#InnoDB存储引擎对MVCC的实现" class="headerlink" title="InnoDB存储引擎对MVCC的实现"></a>InnoDB存储引擎对MVCC的实现</h3><h4 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h4><p> 在 InnoDB 存储引擎中，<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">多版本控制 (multi versioning)open in new window</a> 就是对非锁定读的实现。如果读取的行正在执行 DELETE 或 UPDATE 操作，这时读取操作不会去等待行上锁的释放。相反地，InnoDB 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)</p>
<h3 id="MySQL时间类型存储建议"><a href="#MySQL时间类型存储建议" class="headerlink" title="MySQL时间类型存储建议"></a>MySQL时间类型存储建议</h3><p>Datetime 和 Timestamp 是 MySQL 提供的两种比较相似的保存时间的数据类型。他们两者究竟该如何选择呢？<br><strong>通常我们都会首选 Timestamp。</strong> 下面说一下为什么这样做!</p>
<h3 id="DateTime-类型没有时区信息"><a href="#DateTime-类型没有时区信息" class="headerlink" title="# DateTime 类型没有时区信息"></a><a href="#datetime-%E7%B1%BB%E5%9E%8B%E6%B2%A1%E6%9C%89%E6%97%B6%E5%8C%BA%E4%BF%A1%E6%81%AF">#</a> DateTime 类型没有时区信息</h3><p><strong>DateTime 类型是没有时区信息的（时区无关）</strong> ，DateTime 类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。不要小看这个问题，很多系统就是因为这个问题闹出了很多笑话。<br><strong>Timestamp 和时区有关</strong>。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。</p>
<p>Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>简介：与传统数据库不同的是，Redis的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且 Redis 存储的是键-值对。</p>
<p><strong>Redis为什么这么快？</strong></p>
<ol>
<li>Redis基于内存，内存的访问速度是磁盘的上千倍。</li>
<li>Redis开发了一套高效的事件处理模型，主要是单线程的多路复用和 IO 多路复用。</li>
<li>Redis内置了多种优化过后的数据结构的实现。</li>
</ol>
<p>说一下Redis和Memcached的区别和共同点？</p>
<blockquote>
<p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p>
</blockquote>
<p><strong>共同点</strong></p>
<ol>
<li>都是基于内存的。</li>
<li>都有过期策略。</li>
<li>两者的性能非常高。</li>
</ol>
<p><strong>区别</strong></p>
<ol>
<li>Redis支持更丰富的数据类型；</li>
<li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启时再加载到内存中，Memcached只能保存在内存中；</li>
<li>Redis有灾难恢复机制，因为可以把缓存中的数据持久化到磁盘中；</li>
<li>Redis支持发布订阅模型，Lua脚本、事务等功能。</li>
<li>Mencached过期数据的删除策略只用了惰性删除，而Redis同时使用了惰性删除和定期删除。</li>
</ol>
<h3 id="常见缓存策略"><a href="#常见缓存策略" class="headerlink" title="常见缓存策略"></a>常见缓存策略</h3><h4 id="Cache-Aside-Pattern-旁路缓存模式"><a href="#Cache-Aside-Pattern-旁路缓存模式" class="headerlink" title="Cache Aside Pattern 旁路缓存模式"></a>Cache Aside Pattern 旁路缓存模式</h4><p>使用较多，比较适合读请求比较多的场景。<br><strong>写</strong></p>
<ul>
<li>先更新 数据库</li>
<li>然后删除 cache</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686321797394-6cf95ffa-8eef-4e3d-bd13-54f2d043f21a.png" alt="image.png"></p>
<p><strong>读</strong></p>
<ul>
<li>从 cache 中读取数据， 读取到就直接返回</li>
<li>cache  中读取不到就从数据库中读取数据返回</li>
<li>再把数据 放入 cache 中</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686321893138-dfd459a0-f75f-4f38-a2f1-afcb09dd15c6.png" alt="image.png"></p>
<p><strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？</strong></p>
<p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成 <strong>数据库（db）和缓存（Cache）数据不一致</strong>的问题。<br>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。<br>这个过程可以简单描述为：<br>请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 A 数据更新</p>
<p>当你这样回答之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</strong>”<br><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。<br>举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。<br>这个过程可以简单描述为：<br>请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -&gt; 请求 1 将数据 A 写入 cache</p>
<p>现在我们再来分析一下 <strong>Cache Aside Pattern 的缺陷</strong>。<br><strong>缺陷 1：首次请求数据一定不在 cache 的问题</strong><br>解决办法：可以将热点数据可以提前放入 cache 中。<br><strong>缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</strong><br>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁&#x2F;分布式锁来保证更新 cache 的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
<h4 id="Read-x2F-Write-Through-Pattern-读写穿透"><a href="#Read-x2F-Write-Through-Pattern-读写穿透" class="headerlink" title="Read &#x2F; Write Through Pattern ( 读写穿透 )"></a>Read &#x2F; Write Through Pattern ( 读写穿透 )</h4><p>Read&#x2F;Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。<br><strong>写 ( Write Through ):</strong></p>
<ul>
<li>先查cache ，cache不存在，直接更新数据库；</li>
<li>cache 中存在，先更新cache，然后cache 服务自己更新数据库；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686365677766-9fbcd262-aad4-4e6e-a38e-0ba306d69dc6.png" alt="image.png"></p>
<p><strong>读（Read Through）</strong></p>
<ul>
<li>从cache中读取数据，读取到就直接返回;</li>
<li>读取不到，先从数据库中加载，写入cache 后返回响应；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686365808383-bdb93caa-daf2-4773-8409-b6c337065a7e.png" alt="image.png"></p>
<h4 id="Write-Behind-Pattern-异步缓存写入-）"><a href="#Write-Behind-Pattern-异步缓存写入-）" class="headerlink" title="Write Behind Pattern ( 异步缓存写入 ）"></a>Write Behind Pattern ( 异步缓存写入 ）</h4><p>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。<br>但是，两个又有很大的不同：<strong>Read&#x2F;Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong><br>很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。<br>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。<br>Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
<h2 id="Redis的应用"><a href="#Redis的应用" class="headerlink" title="Redis的应用"></a>Redis的应用</h2><ul>
<li>分布式锁：可以给予Redisson来实现分布式锁。</li>
<li>限流：一般通过Redis + Lua 脚本的方式实现。</li>
<li>消息队列：Redis自带的 List 数据结构可以作为一个简单的队列使用。Redis5 中的Stream类更适合用来做消息队列。</li>
</ul>
<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><ul>
<li>5 中基础数据结构： String (字符串）、 List （列表），Set （集合），Hash （散列）， Zset (有序集合）。</li>
<li>3中特殊数据结构： HyperLogLogs （基数统计），Bitmap （位存储）， Geospatial （地理位置）。</li>
</ul>
<p>Redis 基本数据结构的底层数据结构实现如下：</p>
<table>
<thead>
<tr>
<th>String</th>
<th>List</th>
<th>Hash</th>
<th>Set</th>
<th>Zset</th>
</tr>
</thead>
<tbody><tr>
<td>SDS</td>
<td>LinkedList&#x2F;ZipList&#x2F;QuickList</td>
<td>Hash Table、ZipList</td>
<td>ZipList、Intset</td>
<td>ZipList、SkipList</td>
</tr>
</tbody></table>
<h3 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h3><h4 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h4><p> 虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<p><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>SET key value</td>
<td>设置指定 key 的值</td>
</tr>
<tr>
<td>SETNX key value</td>
<td>只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td>GET key</td>
<td>获取指定 key 的值</td>
</tr>
<tr>
<td>MSET key1 value1 key2 value2 …</td>
<td>设置一个或多个指定 key 的值</td>
</tr>
<tr>
<td>MGET key1 key2 …</td>
<td>获取一个或多个指定 key 的值</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>返回 key 所储存的字符串值的长度</td>
</tr>
<tr>
<td>INCR key</td>
<td>将 key 中储存的数字值增一</td>
</tr>
<tr>
<td>DECR key</td>
<td>将 key 中储存的数字值减一</td>
</tr>
<tr>
<td>EXISTS key</td>
<td>判断指定 key 是否存在</td>
</tr>
<tr>
<td>DEL key（通用）</td>
<td>删除指定的 key</td>
</tr>
<tr>
<td>EXPIRE key seconds（通用）</td>
<td>给指定 key 设置过期时间</td>
</tr>
</tbody></table>
<h4 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h4><p>Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。<br><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>RPUSH key value1 value2 …</td>
<td>在指定列表的尾部（右边）添加一个或多个元素</td>
</tr>
<tr>
<td>LPUSH key value1 value2 …</td>
<td>在指定列表的头部（左边）添加一个或多个元素</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>将指定列表索引 index 位置的值设置为 value</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移除并获取指定列表的第一个元素(最左边)</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并获取指定列表的最后一个元素(最右边)</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表元素数量</td>
</tr>
<tr>
<td>LRANGE key start end</td>
<td>获取列表 start 和 end 之间 的元素</td>
</tr>
</tbody></table>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。<br>Hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。<br><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>HSET key field value</td>
<td>设置指定哈希表中指定字段的值</td>
</tr>
<tr>
<td>HSETNX key field value</td>
<td>只有指定字段不存在时设置指定字段的值</td>
</tr>
<tr>
<td>HMSET key field1 value1 field2 value2 …</td>
<td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td>
</tr>
<tr>
<td>HGET key field</td>
<td>获取指定哈希表中指定字段的值</td>
</tr>
<tr>
<td>HMGET key field1 field2 …</td>
<td>获取指定哈希表中一个或者多个指定字段的值</td>
</tr>
<tr>
<td>HGETALL key</td>
<td>获取指定哈希表中所有的键值对</td>
</tr>
<tr>
<td>HEXISTS key field</td>
<td>查看指定哈希表中指定的字段是否存在</td>
</tr>
<tr>
<td>HDEL key field1 field2 …</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>HLEN key</td>
<td>获取指定哈希表中字段的数量</td>
</tr>
<tr>
<td>HINCRBY key field increment</td>
<td>对指定哈希中的指定字段做运算操作（正数为加，负数为减）</td>
</tr>
</tbody></table>
<h4 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h4><p> edis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。<br>可以使用 Set 对集合进行一些集合的操作，比如交集，并集等。</p>
<p><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>SADD key member1 member2 …</td>
<td>向指定集合添加一个或多个元素</td>
</tr>
<tr>
<td>SMEMBERS key</td>
<td>获取指定集合中的所有元素</td>
</tr>
<tr>
<td>SCARD key</td>
<td>获取指定集合的元素数量</td>
</tr>
<tr>
<td>SISMEMBER key member</td>
<td>判断指定元素是否在指定集合中</td>
</tr>
<tr>
<td>SINTER key1 key2 …</td>
<td>获取给定所有集合的交集</td>
</tr>
<tr>
<td>SINTERSTORE destination key1 key2 …</td>
<td>将给定所有集合的交集存储在 destination 中</td>
</tr>
<tr>
<td>SUNION key1 key2 …</td>
<td>获取给定所有集合的并集</td>
</tr>
<tr>
<td>SUNIONSTORE destination key1 key2 …</td>
<td>将给定所有集合的并集存储在 destination 中</td>
</tr>
<tr>
<td>SDIFF key1 key2 …</td>
<td>获取给定所有集合的差集</td>
</tr>
<tr>
<td>SDIFFSTORE destination key1 key2 …</td>
<td>将给定所有集合的差集存储在 destination （指定集合）中</td>
</tr>
<tr>
<td>SPOP key count</td>
<td>随机移除并获取指定集合中一个或多个元素</td>
</tr>
<tr>
<td>SRANDMEMBER key count</td>
<td>随机获取指定集合中指定数量的元素</td>
</tr>
</tbody></table>
<h4 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h4><p> Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。<br><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ZADD key score1 member1 score2 member2 …</td>
<td>向指定有序集合添加一个或多个元素</td>
</tr>
<tr>
<td>ZCARD KEY</td>
<td>获取指定有序集合的元素数量</td>
</tr>
<tr>
<td>ZSCORE key member</td>
<td>获取指定有序集合中指定元素的 score 值</td>
</tr>
<tr>
<td>ZINTERSTORE destination numkeys key1 key2 …</td>
<td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td>
</tr>
<tr>
<td>ZUNIONSTORE destination numkeys key1 key2 …</td>
<td>求并集，其它和 ZINTERSTORE 类似</td>
</tr>
<tr>
<td>ZDIFFSTORE destination numkeys key1 key2 …</td>
<td>求差集，其它和 ZINTERSTORE 类似</td>
</tr>
<tr>
<td>ZRANGE key start end</td>
<td>获取指定有序集合 start 和 end 之间的元素（score 从低到高）</td>
</tr>
<tr>
<td>ZREVRANGE key start end</td>
<td>获取指定有序集合 start 和 end 之间的元素（score 从高到底）</td>
</tr>
<tr>
<td>ZREVRANK key member</td>
<td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td>
</tr>
</tbody></table>
<h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><p> Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。<br>常<strong>常</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>SETBIT key offset value</td>
<td>设置指定 offset 位置的值</td>
</tr>
<tr>
<td>GETBIT key offset</td>
<td>获取指定 offset 位置的值</td>
</tr>
<tr>
<td>BITCOUNT key start end</td>
<td>获取 start 和 end 之前值为 1 的元素个数</td>
</tr>
<tr>
<td>BITOP operation destkey key1 key2 …</td>
<td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td>
</tr>
</tbody></table>
<blockquote>
<p>可以应用于用户签到</p>
</blockquote>
<h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><p>HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。<br>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近2^64个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p>
<ul>
<li><strong>稀疏矩阵</strong>：计数较少的时候，占用空间很小。</li>
<li><strong>稠密矩阵</strong>：计数达到某个阈值的时候，占用 12k 的空间。</li>
</ul>
<h4 id="Geospatial-index"><a href="#Geospatial-index" class="headerlink" title="Geospatial index"></a>Geospatial index</h4><p>简称 GEO 主要用于存储地理位置信息，基于 Sorted Set 实现。<br>通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。<br><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>GEOADD key longitude1 latitude1 member1 …</td>
<td>添加一个或多个元素对应的经纬度信息到 GEO 中</td>
</tr>
<tr>
<td>GEOPOS key member1 member2 …</td>
<td>返回给定元素的经纬度信息</td>
</tr>
<tr>
<td>GEODIST key member1 member2 M&#x2F;KM&#x2F;FT&#x2F;MI</td>
<td>返回两个给定元素之间的距离</td>
</tr>
<tr>
<td>GEORADIUS key longitude latitude radius distance</td>
<td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数</td>
</tr>
<tr>
<td>GEORADIUSBYMEMBER key member radius distance</td>
<td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td>
</tr>
</tbody></table>
<h3 id="关于对象的存储使用-String-还是-hash？"><a href="#关于对象的存储使用-String-还是-hash？" class="headerlink" title="关于对象的存储使用 String 还是 hash？"></a>关于对象的存储使用 String 还是 hash？</h3><ul>
<li>String 存储的是序列化之后的对象数据。Hash 是将对象的每个字段单独存储。如果对象中某些字段需要经常变动或者单独查询对象中的个别字段信息，推荐使用Hash。</li>
<li>String 存储相对 Hash 来说更加的节省内存，基本上 String 消耗内存是 Hash的一半。</li>
</ul>
<p><strong>绝大部分下，建议使用 String 存储对象数据。</strong></p>
<h3 id="String-底层实现"><a href="#String-底层实现" class="headerlink" title="String 底层实现"></a>String 底层实现</h3><p> Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 \0 结尾的字符数组），而是自己编写了 <a target="_blank" rel="noopener" href="https://github.com/antirez/sds">SDSopen in new window</a>（Simple Dynamic String，简单<strong>动态</strong>字符串） 来作为底层实现。</p>
<h3 id="Redis-实现排行榜"><a href="#Redis-实现排行榜" class="headerlink" title="Redis 实现排行榜"></a>Redis 实现排行榜</h3><p>相关的一些 Redis 命令: ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。</p>
<h2 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h2><p>Redis持久化方式</p>
<ul>
<li>快照 ( anspshotting, RDB )</li>
<li>只追加文件 （ append-only file,AOF )</li>
<li>RDB 与 AOF 的混合持久化（ Redis 4.0 新增 )</li>
</ul>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p> Redis 可以通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。<br>快照持久化是 Redis 默认采用的持久化方式，在 redis.conf 配置文件中默认有此下配置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>           #在<span class="number">900</span>秒(<span class="number">15</span>分钟)之后，如果至少有<span class="number">1</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>          #在<span class="number">300</span>秒(<span class="number">5</span>分钟)之后，如果至少有<span class="number">10</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>        #在<span class="number">60</span>秒(<span class="number">1</span>分钟)之后，如果至少有<span class="number">10000</span>个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="RDB创建快照会阻塞主线程吗？"><a href="#RDB创建快照会阻塞主线程吗？" class="headerlink" title="RDB创建快照会阻塞主线程吗？"></a>RDB创建快照会阻塞主线程吗？</h4><p>Redis 提供了两个命令来生成RDB 快照：</p>
<ul>
<li>save ： 同步保存操作， 会阻塞主线程</li>
<li>bgsave： fork 出一个子线程， 子进程执行，不会阻塞 Redis 主线程，默认选项。</li>
</ul>
<h3 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h3><p>与快照持久化相比，AOF 持久化的效果更好。默认情况下 Redis 没有开启 AOF 方式的持久化 （ Redis 6.0 之后默认开启。可以通过 appendonly 开启。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 server.aof_buf 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ fsync策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。<br>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。<br>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p>
<h4 id="AOF-工作基本流程是怎么样的？"><a href="#AOF-工作基本流程是怎么样的？" class="headerlink" title="# AOF 工作基本流程是怎么样的？"></a><a href="#aof-%E5%B7%A5%E4%BD%9C%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84">#</a> AOF 工作基本流程是怎么样的？</h4><ol>
<li>命令追加 （ append）： 所有的写命令会追加到 AOF 缓冲区中。</li>
<li>文件写<strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</li>
<li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用write函数（系统调用），write将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</li>
<li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ fsync 策略）向硬盘做同步操作。这一步需要调用 fsync 函数（系统调用）， fsync 针对单个文件操作，对其进行强制硬盘同步，fsync 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li>
<li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>
<li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>
</ol>
<p>Linux 系统直接提供了一些函数用于对文件和设备进行访问和控制，这些函数被称为 <strong>系统调用（syscall）</strong>。<br>这里对上面提到的一些 Linux 系统调用再做一遍解释：</p>
<ul>
<li>write：写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I&#x2F;O 缓冲区的状态。</li>
<li>fsync：fsync用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686381698802-5049b6cd-a877-4b1f-abf5-e41bfe57950a.png" alt="image.png"></p>
<h4 id="AOF-持久化方式有哪些？"><a href="#AOF-持久化方式有哪些？" class="headerlink" title="AOF 持久化方式有哪些？"></a>AOF 持久化方式有哪些？</h4><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ fsync策略），它们分别是：</p>
<ol>
<li>appendfsync always：主线程调用 write 执行写操作后，后台线程（ aof_fsync 线程）立即会调用 fsync 函数同步 AOF 文件（刷盘），fsync 完成后线程返回，这样会严重降低 Redis 的性能（write + fsync）。</li>
<li>appendfsync everysec：主线程调用 write 执行写操作后立即返回，由后台线程（ aof_fsync 线程）每秒钟调用 fsync 函数（系统调用）同步一次 AOF 文件（write+fsync，fsync间隔为 1 秒）</li>
<li>appendfsync no：主线程调用 write 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（write但不fsync，fsync 的时机由操作系统决定）。</li>
</ol>
<p>一般使用 appendfsync 即可。</p>
<h4 id="AOF-为什么是在执行完命令之后记录日志？"><a href="#AOF-为什么是在执行完命令之后记录日志？" class="headerlink" title="AOF 为什么是在执行完命令之后记录日志？"></a>AOF 为什么是在执行完命令之后记录日志？</h4><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686381921221-9f9709be-bd7a-4292-91ad-9bf196df67e8.png" alt="AOF 记录日志过程"><br><strong>为什么是在执行完命令之后记录日志呢？</strong></p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>
</ul>
<h4 id="AOF-重写了解吗？"><a href="#AOF-重写了解吗？" class="headerlink" title="AOF 重写了解吗？"></a>AOF 重写了解吗？</h4><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686382523638-a880a752-f6d4-4a80-b697-eef70b13c46a.png" alt="AOF 重写"></p>
<p>AOF 重写（rewrite） 是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>
<h3 id="RDB-与-AOF-混合"><a href="#RDB-与-AOF-混合" class="headerlink" title="RDB 与 AOF 混合"></a>RDB 与 AOF 混合</h3><p>由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。<br>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差</p>
<h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><p> 对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。<br>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p>
<ul>
<li>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I&#x2F;O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
<h3 id="IO-多路复用在-Redis-中的应用"><a href="#IO-多路复用在-Redis-中的应用" class="headerlink" title="IO 多路复用在 Redis 中的应用"></a>IO 多路复用在 Redis 中的应用</h3><p>Redis 服务器是一个事件驱动程序， 服务器处理的事件分为时间事件和文件事件两类。</p>
<ul>
<li><strong>文件事件</strong>：Redis 主进程中，主要处理客户端的连接请求与相应。</li>
<li><strong>时间事件</strong>：fork 出的子进程中，处理如 AOF 持久化任务等。</li>
</ul>
<p>由于 Redis 的文件事件是单进程，单线程模型，但是确保持着优秀的吞吐量，IO 多路复用起到了主要作用。<br>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。<br>IO 多路复用程序负责监听多个套接字并向文件事件分派器传送那些产生了事件的套接字。文件事件分派器接收 IO 多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。示例如图所示：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686386947601-0740a824-9bba-48b0-b4ed-530d26adc4bd.png" alt="image.png"></p>
<h3 id="Redis6-0-之前为什么不使用多线程？-我觉得主要原因有-3-点："><a href="#Redis6-0-之前为什么不使用多线程？-我觉得主要原因有-3-点：" class="headerlink" title="Redis6.0 之前为什么不使用多线程？ 我觉得主要原因有 3 点："></a>Redis6.0 之前为什么不使用多线程？ 我觉得主要原因有 3 点：</h3><ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<h3 id="Redis6-0-之后为何引入了多线程？"><a href="#Redis6-0-之后为何引入了多线程？" class="headerlink" title="Redis6.0 之后为何引入了多线程？"></a>Redis6.0 之后为何引入了多线程？</h3><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。<br>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。<br>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 &gt; 1，需要修改 redis 配置文件 redis.conf：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure>

<p>另外：</p>
<ul>
<li>io-threads 的个数一旦设置，不能通过 config 动态设置。</li>
<li>当设置 ssl 后，io-threads 将不工作。</li>
</ul>
<p>开启多线程后，默认只会使用多线程进行 IO 写入 writes，即发送数据给客户端，如果需要开启多线程 IO 读取 reads，同样需要修改 redis 配置文件 redis.conf :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</p>
<h2 id="Redis-内存管理"><a href="#Redis-内存管理" class="headerlink" title="Redis 内存管理"></a>Redis 内存管理</h2><p><strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 setex 外，其他方法都需要依靠 expire 命令来设置过期时间 。另外， persist 命令可以移除一个键的过期时间。</strong></p>
<h3 id="Redis-是如何判断数据是否过期的呢？"><a href="#Redis-是如何判断数据是否过期的呢？" class="headerlink" title="Redis 是如何判断数据是否过期的呢？"></a>Redis 是如何判断数据是否过期的呢？</h3><p> Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict <span class="operator">*</span>dict;     <span class="operator">/</span><span class="operator">/</span>数据库键空间,保存着数据库中所有键值对</span><br><span class="line">    dict <span class="operator">*</span>expires   <span class="operator">/</span><span class="operator">/</span> 过期字典,保存着键的过期时间</span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686387531360-b25909cc-c539-4436-868c-70ea63e7b7a1.png" alt="Redis过期字典"></p>
<h4 id="过期的数据删除策略"><a href="#过期的数据删除策略" class="headerlink" title="过期的数据删除策略"></a>过期的数据删除策略</h4><p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol>
<li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。<br>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。<br>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制</strong></p>
<h3 id="Redis-内存淘汰机制了解么？"><a href="#Redis-内存淘汰机制了解么？" class="headerlink" title="Redis 内存淘汰机制了解么？"></a>Redis 内存淘汰机制了解么？</h3><blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰。</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li>
</ol>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>你可以将 Redis 中的事务理解为：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<h2 id="Redis性能优化"><a href="#Redis性能优化" class="headerlink" title="Redis性能优化"></a>Redis性能优化</h2><h3 id="使用批量操作减少网络传输"><a href="#使用批量操作减少网络传输" class="headerlink" title="使用批量操作减少网络传输"></a>使用批量操作减少网络传输</h3><p>一个Redis 命令可以简化为一下4个步骤</p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。<br>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。<br>另外，除了能减少 RTT 之外，发送一次命令的 socket I&#x2F;O 成本也比较高（涉及上下文切换，存在read()和write()系统调用），批量操作还可以减少 socket I&#x2F;O 成本。这个在官方对 pipeline 的介绍中有提到：<a target="_blank" rel="noopener" href="https://redis.io/docs/manual/pipelining/">https://redis.io/docs/manual/pipelining/</a> 。</p>
<h3 id="原生批量操作命令"><a href="#原生批量操作命令" class="headerlink" title="原生批量操作命令"></a>原生批量操作命令</h3><p>Redis 中有一些原生支持批量操作的命令，比如：</p>
<ul>
<li>MGET(获取一个或多个指定 key 的值)、MSET(设置一个或多个指定 key 的值)、</li>
<li>HMGET(获取指定哈希表中一个或者多个指定字段的值)、HMSET(同时将一个或多个 field-value 对设置到指定哈希表中)、</li>
<li>SADD（向指定集合添加一个或多个元素）</li>
</ul>
<h3 id="如何找到慢查询命令？"><a href="#如何找到慢查询命令？" class="headerlink" title="如何找到慢查询命令？"></a>如何找到慢查询命令？</h3><p>在 redis.conf 文件中，我们可以使用 slowlog-log-slower-than 参数设置耗时命令的阈值，并使用 slowlog-max-len 参数设置耗时命令的最大记录条数。<br>当 Redis 服务器检测到执行时间超过 slowlog-log-slower-than阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。<br>⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。</p>
<h2 id="Redis内存碎片"><a href="#Redis内存碎片" class="headerlink" title="Redis内存碎片"></a>Redis内存碎片</h2><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ol>
<li>Redis存储数据时向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</li>
<li>频繁的修改数据，当 Redis 中的某个数据删除时， Redis 通常不会轻易释放内存给操作系统</li>
</ol>
<h3 id="如何清理-Redis-内存碎片"><a href="#如何清理-Redis-内存碎片" class="headerlink" title="如何清理 Redis 内存碎片"></a>如何清理 Redis 内存碎片</h3><p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。<br>直接通过 config set 命令将 activedefrag 配置项设置为 yes 即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> activedefrag <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>具体什么时候清理需要通过下面两个参数控制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存碎片占用空间达到 500mb 的时候开始清理</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-ignore-bytes 500mb</span><br><span class="line"><span class="comment"># 内存碎片率大于 1.5 的时候开始清理</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-threshold-lower 50</span><br></pre></td></tr></table></figure>

<p>通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-cycle-min 20</span><br><span class="line"><span class="comment"># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span></span><br><span class="line">config <span class="built_in">set</span> active-defrag-cycle-max 50</span><br></pre></td></tr></table></figure>

<p>另外，重启节点可以做到内存碎片重新整理。如果你采用的是高可用架构的 Redis 集群的话，你可以将碎片率过高的主节点转换为从节点，以便进行安全重启。</p>
<h2 id="缓存和数据库一致性问题"><a href="#缓存和数据库一致性问题" class="headerlink" title="缓存和数据库一致性问题"></a>缓存和数据库一致性问题</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">https://mp.weixin.qq.com/s?__biz&#x3D;MzIyOTYxNDI5OA&#x3D;&#x3D;&amp;mid&#x3D;2247487312&amp;idx&#x3D;1&amp;sn&#x3D;fa19566f5729d6598155b5c676eee62d&amp;chksm&#x3D;e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&amp;scene&#x3D;178&amp;cur_album_id&#x3D;1699766580538032128#rd</a></p>
</blockquote>
<h3 id="缓存利用和一致性问题"><a href="#缓存利用和一致性问题" class="headerlink" title="缓存利用和一致性问题"></a>缓存利用和一致性问题</h3><p>想要缓存利用率「最大化」，我们很容易想到的方案是，缓存中只保留最近访问的「热数据」。但具体要怎么做呢？<br>我们可以这样优化：</p>
<ul>
<li>写请求依旧只写数据库</li>
<li>读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存</li>
<li>同时，写入缓存中的数据，都设置失效时间再来看数据一致性问题。</li>
</ul>
<p>要想保证缓存和数据库「实时」一致，那就不能再用定时任务刷新缓存了。<br>所以，当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存。具体操作就是，修改一条数据时，不仅要更新数据库，也要连带缓存一起更新。<br>但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：</p>
<ol>
<li>先更新缓存，后更新数据库</li>
<li>先更新数据库，后更新缓存</li>
</ol>
<p>哪个方案更好呢？<br>先不考虑并发问题，正常情况下，无论谁先谁后，都可以让两者保持一致，但现在我们需要重点考虑「异常」情况。<br>因为操作分为两步，那么就很有可能存在「第一步成功、第二步失败」的情况发生。<br><strong>1) 先更新缓存，后更新数据库</strong><br>如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。<br>虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。<br>这时用户会发现自己之前修改的数据又「变回去」了，对业务造成影响。<br><strong>2) 先更新数据库，后更新缓存</strong><br>如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。<br>之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。<br>这时用户会发现，自己刚刚修改了数据，但却看不到变更，一段时间过后，数据才变更过来，对业务也会有影响。<br>可见，无论谁先谁后，但凡后者发生异常，就会对业务造成影响。那怎么解决这个问题呢？<br>别急，后面我会详细给出对应的解决方案。<br>我们继续分析，除了操作失败问题，还有什么场景会影响数据一致性？<br>这里我们还需要重点关注：<strong>并发问题</strong>。</p>
<h4 id="并发引发的一致性问题"><a href="#并发引发的一致性问题" class="headerlink" title="并发引发的一致性问题"></a>并发引发的一致性问题</h4><p>假设我们采用「先更新数据库，再更新缓存」的方案，并且两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？<br>有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：</p>
<ol>
<li>线程 A 更新数据库（X &#x3D; 1）</li>
<li>线程 B 更新数据库（X &#x3D; 2）</li>
<li>线程 B 更新缓存（X &#x3D; 2）</li>
<li>线程 A 更新缓存（X &#x3D; 1）</li>
</ol>
<p>最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。<br>也就是说，A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。<br>同样地，采用「先更新缓存，再更新数据库」的方案，也会有类似问题，这里不再详述。</p>
<p>，虽然我们想通过重试的方式解决问题，但这种「同步」重试的方案依旧不严谨。<br>那更好的方案应该怎么做？<br>答案是：<strong>异步重试</strong>。什么是异步重试？<br>其实就是把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。<br>或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。<br>到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？<br>这个问题很好，但我们思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。<br>所以，这里我们必须把重试或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：</p>
<ul>
<li><strong>消息队列保证可靠性</strong>：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）</li>
<li><strong>消息队列保证消息成功投递</strong>：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/35372544/1686406377648-181b8085-f065-4042-bfeb-0c5ea59c1c35.png" alt="image.png"></p>
<h2 id="Redis-常见阻塞原因总结"><a href="#Redis-常见阻塞原因总结" class="headerlink" title="Redis 常见阻塞原因总结"></a>Redis 常见阻塞原因总结</h2><ol>
<li>O（n）命令</li>
</ol>
<ul>
<li>KEYS *：会返回所有符合规则的 key。</li>
<li>HGETALL：会返回一个 Hash 中所有的键值对。</li>
<li>LRANGE：会返回 List 中指定范围内的元素。</li>
<li>SMEMBERS：返回 Set 中的所有元素。</li>
<li>SINTER&#x2F;SUNION&#x2F;SDIFF：计算多个 Set 的交集&#x2F;并集&#x2F;差集。</li>
</ul>
<ol start="2">
<li>SAVE 创建 RDB 快照<ol>
<li>save :  同步保存操作， 会阻塞主线程</li>
<li>bgsave： fork出一个子线程，不会阻塞主线程</li>
</ol>
</li>
<li>AOF <ol>
<li>AOF 日志记录阻塞</li>
<li>AOF 刷盘阻塞</li>
<li>AOF 重新阻塞</li>
</ol>
<ul>
<li>fork 出一条子线程来将文件重写，在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。</li>
<li>当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。</li>
<li>最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</li>
</ul>
</li>
<li>大 key</li>
<li>清空数据库</li>
<li>集群扩容</li>
</ol>
<p>Redis 集群可以进行节点的动态扩容缩容，这一过程目前还处于半自动状态，需要人工介入。<br>在扩缩容的时候，需要进行数据迁移。而 Redis 为了保证迁移的一致性，迁移所有操作都是同步操作。<br>执行迁移时，两端的 Redis 均会进入时长不等的阻塞状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会触发集群内的故障转移，造成不必要的切换。</p>
<ol start="7">
<li><p>Swap 内存交换</p>
<p>  <strong>什么是 Swap？</strong> Swap 直译过来是交换的意思，Linux 中的 Swap 常被称为内存交换或者交换分区。类似于 Windows 中的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用，从而解决内存容量不足的情况。因此，Swap 分区的作用就是牺牲硬盘，增加内存，解决 VPS 内存不够用或者爆满的问题。</p>
</li>
</ol>
<p>Swap 对于 Redis 来说是非常致命的，Redis 保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把 Redis 使用的部分内存换出硬盘，由于内存与硬盘读写的速度并几个数量级，会导致发生交换后的 Redis 性能急剧下降。</p>
<ol start="8">
<li>CPU 竞争</li>
<li>网络问题</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://tangxy1024.github.io">从来不卷</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://tangxy1024.github.io/2023/06/17/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/">http://tangxy1024.github.io/2023/06/17/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://tangxy1024.github.io" target="_blank">有啥好卷的</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201301.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/17/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><img class="cover" src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201301.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试题</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/17/Vue/" title="Vue"><img class="cover" src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201307.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vue</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/17/%E9%9D%A2%E8%AF%95--%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/" title="面试-项目工具"><img class="cover" src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201301.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-17</div><div class="title">面试-项目工具</div></div></a></div><div><a href="/2023/06/17/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><img class="cover" src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201301.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-17</div><div class="title">面试题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/logo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">从来不卷</div><div class="author-info__description">不乱于心，不困于情，不畏将来，不念过往。如此，安好。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tangxy1024/tangxy1024.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tangxy1024/tangxy1024.github.io" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/txy1813932938" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我的学习笔记</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">Java后端知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C"><span class="toc-number">3.</span> <span class="toc-text">面试经验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%AD%E5%B7%9E%E5%A4%A9%E8%B0%B7%E4%BF%A1%E6%81%AF%E7%A7%91%E6%8A%80%E6%9C%89%E9%99%90%E5%85%AC%E5%8F%B8"><span class="toc-number">3.1.</span> <span class="toc-text">杭州天谷信息科技有限公司</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%94%E8%AF%95"><span class="toc-number">3.1.1.</span> <span class="toc-text">笔试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E6%B5%B7%E8%9A%81%E5%9F%8E%E7%A7%91%E6%8A%80"><span class="toc-number">3.2.</span> <span class="toc-text">上海蚁城科技</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%88%E9%98%B3%E4%B8%9C%E6%95%B0%E4%BF%A1%E6%81%AF"><span class="toc-number">3.3.</span> <span class="toc-text">沈阳东数信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%85%AB%E8%82%A1%E6%96%87"><span class="toc-number">4.</span> <span class="toc-text">Java八股文</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E6%8A%80%E6%9C%AF"><span class="toc-number">4.2.</span> <span class="toc-text">逃逸技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">5.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-number">6.</span> <span class="toc-text">逃逸分析技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%83%E9%80%B8"><span class="toc-number">6.1.</span> <span class="toc-text">线程逃逸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%80%83%E9%80%B8"><span class="toc-number">6.2.</span> <span class="toc-text">方法逃逸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%8D%E9%80%83%E9%80%B8"><span class="toc-number">6.3.</span> <span class="toc-text">从不逃逸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="toc-number">6.4.</span> <span class="toc-text">优化手段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="toc-number">6.4.1.</span> <span class="toc-text">栈上分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-number">6.4.2.</span> <span class="toc-text">标量替换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E5%92%8C%E8%81%9A%E5%90%88%E9%87%8F"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">标量和聚合量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2-1"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">标量替换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%B6%88%E9%99%A4"><span class="toc-number">6.4.3.</span> <span class="toc-text">同步消除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.5.</span> <span class="toc-text">Java类加载顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.6.</span> <span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">6.6.1.</span> <span class="toc-text">包装类型的缓存机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final"><span class="toc-number">6.6.2.</span> <span class="toc-text">final</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">6.7.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">6.7.1.</span> <span class="toc-text">静态方法和实例方法有何不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E8%A6%81%E9%81%B5%E5%BE%AA%E2%80%9C%E4%B8%A4%E5%90%8C%E4%B8%A4%E5%B0%8F%E4%B8%80%E5%A4%A7%E2%80%9D%EF%BC%88%E5%A4%96%E7%9B%92%E4%B8%8D%E5%8F%98%EF%BC%8C%E5%86%85%E6%A0%B8%E6%94%B9%E5%8F%98%EF%BC%89"><span class="toc-number">6.7.2.</span> <span class="toc-text">方法的重写要遵循“两同两小一大”（外盒不变，内核改变）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">6.7.3.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="toc-number">6.7.4.</span> <span class="toc-text">可变长参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="toc-number">6.8.</span> <span class="toc-text">面向对象基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">6.8.1.</span> <span class="toc-text">面向对象的三大特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.8.2.</span> <span class="toc-text">接口和抽象类有什么共同点和区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">6.8.3.</span> <span class="toc-text">深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99equals"><span class="toc-number">6.8.4.</span> <span class="toc-text">重写equals</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">6.9.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuffer%E4%B8%AD%E7%9A%84capacity%E7%9A%84%E6%89%A9%E5%A2%9E%E6%9C%BA%E5%88%B6"><span class="toc-number">6.9.1.</span> <span class="toc-text">StringBuffer中的capacity的扩增机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4String%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%9F"><span class="toc-number">6.9.2.</span> <span class="toc-text">为什么说String类型不可变？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-intern-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">6.9.3.</span> <span class="toc-text">String#intern 方法有什么作用?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">6.10.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Checked-Exception-%E5%92%8C-Unchecked-Exception-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.10.1.</span> <span class="toc-text">Checked Exception 和 Unchecked Exception 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-with-resources%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.10.2.</span> <span class="toc-text">try-with-resources语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">6.11.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">6.11.1.</span> <span class="toc-text">获取Class对象的四种方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPI"><span class="toc-number">6.12.</span> <span class="toc-text">SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SPI%E4%B8%8EAPI"><span class="toc-number">6.12.1.</span> <span class="toc-text">SPI与API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">6.13.</span> <span class="toc-text">序列化与反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94%E4%BA%8E-TCP-x2F-IP-4-%E5%B1%82%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-number">6.13.1.</span> <span class="toc-text">序列化协议对应于 TCP&#x2F;IP 4 层模型的哪一层？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%AE%9A%E6%9F%90%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">6.13.2.</span> <span class="toc-text">规定某些字段不进行序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-JDK-%E8%87%AA%E5%B8%A6%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">6.13.3.</span> <span class="toc-text">为什么不推荐使用 JDK 自带的序列化？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-x2F-O"><span class="toc-number">6.14.</span> <span class="toc-text">I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.15.</span> <span class="toc-text">Java代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">6.15.1.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">6.15.2.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">6.15.2.1.</span> <span class="toc-text">JDK代理机制：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">6.15.3.</span> <span class="toc-text">CGLIB动态代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal%E7%9A%84%E7%94%A8%E5%A4%84"><span class="toc-number">6.16.</span> <span class="toc-text">BigDecimal的用处</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4"><span class="toc-number">6.16.1.</span> <span class="toc-text">加减乘除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E9%AD%94%E6%B3%95%E7%B1%BB-Unsafe-%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.17.</span> <span class="toc-text">Java 魔法类 Unsafe 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">6.17.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">6.18.</span> <span class="toc-text">Java语法糖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">6.18.1.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E8%A8%80"><span class="toc-number">6.18.2.</span> <span class="toc-text">断言</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">7.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">7.1.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0-RandomAccess-%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">7.1.1.</span> <span class="toc-text">LinkedList 为什么不能实现 RandomAccess 接口？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E4%B8%8ELinkedList%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.1.2.</span> <span class="toc-text">ArrayList与LinkedList区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RandomAccess%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.1.3.</span> <span class="toc-text">RandomAccess接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">7.2.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparable%E4%B8%8EComparator%E5%8C%BA%E5%88%AB"><span class="toc-number">7.2.1.</span> <span class="toc-text">Comparable与Comparator区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">7.2.2.</span> <span class="toc-text">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue"><span class="toc-number">7.3.</span> <span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue%E4%B8%8EDeque%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.3.1.</span> <span class="toc-text">Queue与Deque的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBlokingQueue"><span class="toc-number">7.3.2.</span> <span class="toc-text">什么是BlokingQueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">7.4.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E4%B8%8EHashTable%E5%8C%BA%E5%88%AB"><span class="toc-number">7.4.1.</span> <span class="toc-text">HashMap与HashTable区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet-%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D"><span class="toc-number">7.4.2.</span> <span class="toc-text">HashSet 如何检查重复?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.4.3.</span> <span class="toc-text">HashMap的底层实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1"><span class="toc-number">7.4.4.</span> <span class="toc-text">HashMap 的长度为什么是 2 的幂次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-1-7-%E5%92%8C-JDK-1-8-%E7%9A%84-ConcurrentHashMap-%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">7.4.5.</span> <span class="toc-text">JDK 1.7 和 JDK 1.8 的 ConcurrentHashMap 实现有什么不同？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">7.5.</span> <span class="toc-text">集合使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%BD%ACMap"><span class="toc-number">7.5.1.</span> <span class="toc-text">集合转Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">7.5.2.</span> <span class="toc-text">集合转数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BD%AC%E9%9B%86%E5%90%88"><span class="toc-number">7.5.3.</span> <span class="toc-text">数组转集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#System-arraycopy-%E5%92%8C-Arrays-copyOf-%E6%96%B9%E6%B3%95"><span class="toc-number">7.5.4.</span> <span class="toc-text">System.arraycopy() 和 Arrays.copyOf()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">7.6.</span> <span class="toc-text">源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-number">7.6.1.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">7.6.2.</span> <span class="toc-text">ConcurrentHashMap</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number"></span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98"><span class="toc-number">0.1.</span> <span class="toc-text">什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%83%E7%BB%84-%E7%A0%81-%E5%80%99%E9%80%89%E7%A0%81-%E4%B8%BB%E7%A0%81-%E5%A4%96%E7%A0%81-%E4%B8%BB%E5%B1%9E%E6%80%A7-%E9%9D%9E%E4%B8%BB%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">0.2.</span> <span class="toc-text">什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ER%E5%9B%BE"><span class="toc-number">0.3.</span> <span class="toc-text">ER图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%88%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F%EF%BC%89"><span class="toc-number">0.4.</span> <span class="toc-text">表设计的原则（三大范式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE%E5%92%8C%E7%BA%A7%E8%81%94"><span class="toc-number">0.5.</span> <span class="toc-text">不推荐使用外键和级联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">0.6.</span> <span class="toc-text">什么是存储过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drop%E3%80%81delete-%E4%B8%8E-truncate-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">0.7.</span> <span class="toc-text">drop、delete 与 truncate 区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95%E4%B8%8D%E5%90%8C"><span class="toc-number">0.7.1.</span> <span class="toc-text"> 用法不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E4%BA%8E%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80"><span class="toc-number">0.7.2.</span> <span class="toc-text"> 属于不同的数据库语言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%88%E4%B9%8B%E5%90%8E%E8%AF%A6%E7%BB%86%E7%9C%8B%EF%BC%89"><span class="toc-number">0.8.</span> <span class="toc-text">触发器（之后详细看）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E9%80%9A%E5%B8%B8%E5%88%86%E4%B8%BA%E9%82%A3%E5%87%A0%E6%AD%A5%EF%BC%9F"><span class="toc-number">0.9.</span> <span class="toc-text">数据库设计通常分为那几步？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">0.10.</span> <span class="toc-text">NoSQL基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">0.10.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E4%B8%8ENoSQL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">0.10.2.</span> <span class="toc-text">SQL与NoSQL的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NoSQL%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">0.10.3.</span> <span class="toc-text">NoSQL的优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E8%AF%AD%E6%B3%95"><span class="toc-number">0.11.</span> <span class="toc-text">SQL语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E5%88%86%E7%B1%BB"><span class="toc-number">0.11.1.</span> <span class="toc-text">SQL分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-number">0.11.2.</span> <span class="toc-text">查询语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">0.11.3.</span> <span class="toc-text">子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%BB%84%E5%90%88"><span class="toc-number">0.11.4.</span> <span class="toc-text">连接和组合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5-%EF%BC%88JOIN%EF%BC%89"><span class="toc-number">0.11.4.1.</span> <span class="toc-text">连接 （JOIN）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88-%EF%BC%88UNION"><span class="toc-number">0.11.4.2.</span> <span class="toc-text">组合 （UNION)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">0.12.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="toc-number">0.12.1.</span> <span class="toc-text">文本处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="toc-number">0.12.2.</span> <span class="toc-text">日期和时间处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#having"><span class="toc-number">0.12.3.</span> <span class="toc-text">having</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8"><span class="toc-number">0.13.</span> <span class="toc-text">修改数据库表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%88%97"><span class="toc-number">0.13.0.1.</span> <span class="toc-text">修改列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%BB%E9%94%AE"><span class="toc-number">0.13.0.2.</span> <span class="toc-text">添加主键</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">0.14.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE"><span class="toc-number">0.14.0.1.</span> <span class="toc-text">创建视图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">0.15.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">0.15.1.</span> <span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">0.15.2.</span> <span class="toc-text">创建唯一索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">0.15.3.</span> <span class="toc-text">删除索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">0.16.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#check"><span class="toc-number">0.16.0.1.</span> <span class="toc-text">check</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">0.17.</span> <span class="toc-text">事务处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">0.18.</span> <span class="toc-text">权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90"><span class="toc-number">0.18.1.</span> <span class="toc-text">查看权限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9D%83%E9%99%90"><span class="toc-number">0.18.2.</span> <span class="toc-text">删除权限</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%82%A8%E5%AD%98%E8%BF%87%E7%A8%8B"><span class="toc-number">0.19.</span> <span class="toc-text">储存过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87"><span class="toc-number">0.20.</span> <span class="toc-text">游标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">0.21.</span> <span class="toc-text">MySQL面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">0.21.1.</span> <span class="toc-text">MySQL的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E5%82%A8%E5%AD%98%E5%BC%95%E6%93%8E"><span class="toc-number">0.21.2.</span> <span class="toc-text">MySQL储存引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">0.21.3.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">0.21.4.</span> <span class="toc-text">并发事务带来的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%8F%E8%AF%BB"><span class="toc-number">0.21.4.1.</span> <span class="toc-text">脏读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9"><span class="toc-number">0.21.4.2.</span> <span class="toc-text">丢失修改</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">0.21.4.3.</span> <span class="toc-text">不可重复读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB%EF%BC%88%E5%94%AF%E4%B8%80%E7%9A%84%E5%86%99%E6%95%B0%E6%8D%AE%E5%A4%B1%E7%89%A9%EF%BC%89"><span class="toc-number">0.21.4.4.</span> <span class="toc-text">幻读（唯一的写数据失物）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">0.21.5.</span> <span class="toc-text">并发事务的控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">0.21.6.</span> <span class="toc-text">事务隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E9%94%81"><span class="toc-number">0.21.7.</span> <span class="toc-text">MySQL锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F"><span class="toc-number">0.21.8.</span> <span class="toc-text">行级锁的使用有什么注意事项？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">0.21.9.</span> <span class="toc-text">锁的种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E5%AE%83%E9%94%81"><span class="toc-number">0.21.10.</span> <span class="toc-text">共享锁和排它锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">0.21.11.</span> <span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">0.21.12.</span> <span class="toc-text">当前读和快照读有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8-IP-%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">0.21.13.</span> <span class="toc-text">MySQL 如何存储 IP 地址？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90-SQL-%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-number">0.21.14.</span> <span class="toc-text">如何分析 SQL 的性能？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE%E6%80%BB%E7%BB%93"><span class="toc-number">0.22.</span> <span class="toc-text">MySQL高性能优化规范建议总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BD%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E8%A1%A8%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%A4%A7%E5%B0%8F%EF%BC%8C%E5%BB%BA%E8%AE%AE%E6%8E%A7%E5%88%B6%E5%9C%A8-500-%E4%B8%87%E4%BB%A5%E5%86%85"><span class="toc-number">0.22.1.</span> <span class="toc-text">尽量控制单表数据量的大小，建议控制在 500 万以内</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E8%A2%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F%E6%89%80%E6%9D%9F%E7%BC%9A"><span class="toc-number">0.22.2.</span> <span class="toc-text">不要被数据库范式所束缚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E9%BB%98%E8%AE%A4%E5%80%BC%E9%80%89%E5%9E%8B%E6%98%AF%E7%A9%BA%EF%BC%8C%E8%BF%98%E6%98%AFNULL"><span class="toc-number">0.22.3.</span> <span class="toc-text">MySQL默认值选型是空，还是NULL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-TIMESTAMP-4-%E4%B8%AA%E5%AD%97%E8%8A%82-%E6%88%96-DATETIME-%E7%B1%BB%E5%9E%8B-8-%E4%B8%AA%E5%AD%97%E8%8A%82-%E5%AD%98%E5%82%A8%E6%97%B6%E9%97%B4"><span class="toc-number">0.22.4.</span> <span class="toc-text">使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E5%88%97%E5%BB%BA%E8%AE%AE"><span class="toc-number">0.22.5.</span> <span class="toc-text">常见索引列建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">0.22.6.</span> <span class="toc-text">如何选择索引列的顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">0.23.</span> <span class="toc-text">MySQL索引详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B"><span class="toc-number">0.23.1.</span> <span class="toc-text">索引简介</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.1.1.</span> <span class="toc-text">主键索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.1.2.</span> <span class="toc-text">唯一索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%80%BC%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.1.3.</span> <span class="toc-text">单值索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.1.4.</span> <span class="toc-text">复合索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%8F%E8%A1%A8%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.1.5.</span> <span class="toc-text">随表创建索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.2.</span> <span class="toc-text">前缀索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.3.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.4.</span> <span class="toc-text">二级索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-1"><span class="toc-number">0.23.5.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">0.23.5.1.</span> <span class="toc-text">非聚簇索引介绍</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE"><span class="toc-number">0.23.6.</span> <span class="toc-text">正确使用索引的一些建议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%97%E6%AE%B5%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.6.1.</span> <span class="toc-text"> 选择合适的字段创建索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A2%AB%E9%A2%91%E7%B9%81%E6%9B%B4%E6%96%B0%E7%9A%84%E5%AD%97%E6%AE%B5%E5%BA%94%E8%AF%A5%E6%85%8E%E9%87%8D%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.6.2.</span> <span class="toc-text"> 被频繁更新的字段应该慎重建立索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E6%AF%8F%E5%BC%A0%E8%A1%A8%E4%B8%8A%E7%9A%84%E7%B4%A2%E5%BC%95%E6%95%B0%E9%87%8F"><span class="toc-number">0.23.6.3.</span> <span class="toc-text"> 限制每张表上的索引数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E7%9A%84%E8%80%83%E8%99%91%E5%BB%BA%E7%AB%8B%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E8%80%8C%E4%B8%8D%E6%98%AF%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.6.4.</span> <span class="toc-text"> 尽可能的考虑建立联合索引而不是单列索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E9%81%BF%E5%85%8D%E5%86%97%E4%BD%99%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.6.5.</span> <span class="toc-text"> 注意避免冗余索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5%E4%BD%BF%E7%94%A8%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E4%BB%A3%E6%9B%BF%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.6.6.</span> <span class="toc-text"> 字符串类型的字段使用前缀索引代替普通索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">0.23.6.7.</span> <span class="toc-text"> 避免索引失效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%BF%E6%9C%9F%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">0.23.6.8.</span> <span class="toc-text"> 删除长期未使用的索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explain"><span class="toc-number">0.23.7.</span> <span class="toc-text">explain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">0.23.8.</span> <span class="toc-text">查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">0.23.8.1.</span> <span class="toc-text">关联查询优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">0.23.9.</span> <span class="toc-text">慢查询日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-2"><span class="toc-number">0.23.10.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%97%A5%E5%BF%97"><span class="toc-number">0.24.</span> <span class="toc-text">MySQL日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log"><span class="toc-number">0.24.1.</span> <span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-number">0.24.2.</span> <span class="toc-text">刷盘时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog"><span class="toc-number">0.24.3.</span> <span class="toc-text">binlog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">0.24.4.</span> <span class="toc-text">两阶段提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log"><span class="toc-number">0.24.5.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">0.24.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">0.25.</span> <span class="toc-text">InnoDB存储引擎对MVCC的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-number">0.25.1.</span> <span class="toc-text">一致性非锁定读</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">0.26.</span> <span class="toc-text">MySQL时间类型存储建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DateTime-%E7%B1%BB%E5%9E%8B%E6%B2%A1%E6%9C%89%E6%97%B6%E5%8C%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">0.27.</span> <span class="toc-text"> DateTime 类型没有时区信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number"></span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.</span> <span class="toc-text">常见缓存策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache-Aside-Pattern-%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">Cache Aside Pattern 旁路缓存模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Read-x2F-Write-Through-Pattern-%E8%AF%BB%E5%86%99%E7%A9%BF%E9%80%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">Read &#x2F; Write Through Pattern ( 读写穿透 )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Write-Behind-Pattern-%E5%BC%82%E6%AD%A5%E7%BC%93%E5%AD%98%E5%86%99%E5%85%A5-%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">Write Behind Pattern ( 异步缓存写入 ）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">Redis的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">Redis数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">常用的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-1"><span class="toc-number">3.1.1.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List-1"><span class="toc-number">3.1.2.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash"><span class="toc-number">3.1.3.</span> <span class="toc-text">Hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set-1"><span class="toc-number">3.1.4.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sorted-Set"><span class="toc-number">3.1.5.</span> <span class="toc-text">Sorted Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bitmap"><span class="toc-number">3.1.6.</span> <span class="toc-text">Bitmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">3.1.7.</span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Geospatial-index"><span class="toc-number">3.1.8.</span> <span class="toc-text">Geospatial index</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8-String-%E8%BF%98%E6%98%AF-hash%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">关于对象的存储使用 String 还是 hash？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">String 底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-number">3.4.</span> <span class="toc-text">Redis 实现排行榜</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">Redis持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">RDB持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7%E4%BC%9A%E9%98%BB%E5%A1%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">4.1.1.</span> <span class="toc-text">RDB创建快照会阻塞主线程吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">AOF 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E5%B7%A5%E4%BD%9C%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">4.2.1.</span> <span class="toc-text"> AOF 工作基本流程是怎么样的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.2.2.</span> <span class="toc-text">AOF 持久化方式有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%AE%8C%E5%91%BD%E4%BB%A4%E4%B9%8B%E5%90%8E%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-number">4.2.3.</span> <span class="toc-text">AOF 为什么是在执行完命令之后记录日志？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E9%87%8D%E5%86%99%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">4.2.4.</span> <span class="toc-text">AOF 重写了解吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-%E4%B8%8E-AOF-%E6%B7%B7%E5%90%88"><span class="toc-number">4.3.</span> <span class="toc-text">RDB 与 AOF 混合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">Redis 线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%9C%A8-Redis-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">IO 多路复用在 Redis 中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis6-0-%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F-%E6%88%91%E8%A7%89%E5%BE%97%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%E6%9C%89-3-%E7%82%B9%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">Redis6.0 之前为什么不使用多线程？ 我觉得主要原因有 3 点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">Redis6.0 之后为何引入了多线程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">Redis 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">Redis 是如何判断数据是否过期的呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">6.1.1.</span> <span class="toc-text">过期的数据删除策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">Redis 内存淘汰机制了解么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1"><span class="toc-number">7.</span> <span class="toc-text">Redis事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">Redis性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%8F%E5%B0%91%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-number">8.1.</span> <span class="toc-text">使用批量操作减少网络传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">8.2.</span> <span class="toc-text">原生批量操作命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">如何找到慢查询命令？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">9.</span> <span class="toc-text">Redis内存碎片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-number">9.1.</span> <span class="toc-text">产生原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B8%85%E7%90%86-Redis-%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">9.2.</span> <span class="toc-text">如何清理 Redis 内存碎片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">缓存和数据库一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%88%A9%E7%94%A8%E5%92%8C%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">10.1.</span> <span class="toc-text">缓存利用和一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">10.1.1.</span> <span class="toc-text">并发引发的一致性问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%B8%B8%E8%A7%81%E9%98%BB%E5%A1%9E%E5%8E%9F%E5%9B%A0%E6%80%BB%E7%BB%93"><span class="toc-number">11.</span> <span class="toc-text">Redis 常见阻塞原因总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/17/Shiro/" title="Shiro"><img src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201301.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Shiro"/></a><div class="content"><a class="title" href="/2023/06/17/Shiro/" title="Shiro">Shiro</a><time datetime="2023-06-17T12:11:09.000Z" title="发表于 2023-06-17 20:11:09">2023-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/17/Python%E7%88%AC%E8%99%AB/" title="Python爬虫"><img src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201307.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python爬虫"/></a><div class="content"><a class="title" href="/2023/06/17/Python%E7%88%AC%E8%99%AB/" title="Python爬虫">Python爬虫</a><time datetime="2023-06-17T12:09:22.000Z" title="发表于 2023-06-17 20:09:22">2023-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/17/Python%E5%9F%BA%E7%A1%80/" title="Python基础"><img src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201301.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python基础"/></a><div class="content"><a class="title" href="/2023/06/17/Python%E5%9F%BA%E7%A1%80/" title="Python基础">Python基础</a><time datetime="2023-06-17T12:09:12.000Z" title="发表于 2023-06-17 20:09:12">2023-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/17/%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E8%AF%BB%E5%BC%80%E6%BA%90/" title="小白怎么读开源"><img src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201307.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="小白怎么读开源"/></a><div class="content"><a class="title" href="/2023/06/17/%E5%B0%8F%E7%99%BD%E6%80%8E%E4%B9%88%E8%AF%BB%E5%BC%80%E6%BA%90/" title="小白怎么读开源">小白怎么读开源</a><time datetime="2023-06-17T11:57:12.000Z" title="发表于 2023-06-17 19:57:12">2023-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/17/%E9%9D%A2%E8%AF%95--%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/" title="面试-项目工具"><img src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201301.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试-项目工具"/></a><div class="content"><a class="title" href="/2023/06/17/%E9%9D%A2%E8%AF%95--%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/" title="面试-项目工具">面试-项目工具</a><time datetime="2023-06-17T11:57:12.000Z" title="发表于 2023-06-17 19:57:12">2023-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/17/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题"><img src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201301.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题"/></a><div class="content"><a class="title" href="/2023/06/17/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="面试题">面试题</a><time datetime="2023-06-17T11:57:12.000Z" title="发表于 2023-06-17 19:57:12">2023-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/17/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/" title="面经总结"><img src="https://txy-typora.oss-cn-nanjing.aliyuncs.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230616201301.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面经总结"/></a><div class="content"><a class="title" href="/2023/06/17/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/" title="面经总结">面经总结</a><time datetime="2023-06-17T11:57:12.000Z" title="发表于 2023-06-17 19:57:12">2023-06-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 从来不卷</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.19/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.2.0/instantpage.min.js" type="module"></script><div class="js-pjax"></div><script id="click-show-text" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/click-show-text.min.js" data-mobile="false" data-text="从来不卷" data-fontsize="15px" data-random="false" async="async"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="../img/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>